# -*- coding: utf-8 -*-
"""QuantEdge Intelligence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gkmpljoOIvjbKUjTAM0G8OCGRZI-inXT
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from arch import arch_model
from datetime import datetime, timedelta

# --- UI THEME ---
st.set_page_config(page_title="QuantPro Advisor", layout="wide")
st.markdown("""
    <style>
    .stApp { background-color: #f8fafc; color: #1e293b; }
    [data-testid="stMetricValue"] { color: #1e3a8a !important; font-weight: 800; }
    [data-testid="metric-container"] { 
        background-color: #ffffff; border: 1px solid #e2e8f0; 
        border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .valuation-card { 
        padding: 20px; border-radius: 12px; background-color: #ffffff; 
        border: 1px solid #e2e8f0; border-top: 4px solid #2563eb; 
        margin-bottom: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.07);
    }
    .status-undervalued { color: #16a34a; font-weight: bold; }
    .status-overvalued { color: #dc2626; font-weight: bold; }
    </style>
    """, unsafe_allow_html=True)

# --- ASSET UNIVERSE ---
STOCKS = ["RELIANCE.NS", "TCS.NS", "HDFCBANK.NS", "INFY.NS", "SBIN.NS", "ICICIBANK.NS", "TATAMOTORS.NS"]

# --- SIDEBAR ---
st.sidebar.title("ðŸ› ï¸ Global Settings")
sel_stock = st.sidebar.selectbox("Select Asset", STOCKS)
lookback = st.sidebar.slider("Timeframe (Years)", 1, 15, 5)
rf_rate = st.sidebar.number_input("Risk Free Rate %", value=7.1) / 100

@st.cache_data
def get_full_data(ticker, yrs):
    start = datetime.now() - timedelta(days=yrs*365 + 300) 
    df = yf.download([ticker, "^NSEI", "^NSEBANK"], start=start.strftime('%Y-%m-%d'))['Close']
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(1)
    df = df.dropna(subset=[ticker]).ffill()
    return df, df.index[0]

data, listing_date = get_full_data(sel_stock, lookback)

if data is not None:
    tab1, tab2, tab3 = st.tabs(["ðŸ’Ž Valuation & Market", "ðŸ—ï¸ Structural Strength", "ðŸ”® Strategy Playbook"])

    # --- TAB 1: VALUATION ENGINE ---
    with tab1:
        st.title(f"Valuation: {sel_stock}")
        returns = data.pct_change().dropna()
        avg_ann_ret = returns[sel_stock].mean() * 252
        ann_risk = returns[sel_stock].std() * np.sqrt(252)
        sharpe = (avg_ann_ret - rf_rate) / ann_risk if ann_risk != 0 else 0
        
        m1, m2, m3, m4 = st.columns(4)
        m1.metric("Avg Annual Return", f"{avg_ann_ret:.2%}")
        m2.metric("Annualized Risk", f"{ann_risk:.2%}")
        m3.metric("Sharpe Ratio", f"{sharpe:.2f}")
        
        # Valuation Logic
        beta = (returns.cov().loc[sel_stock, "^NSEI"] * 252) / (returns["^NSEI"].var() * 252)
        mkt_ret = returns["^NSEI"].mean() * 252
        
        # 1. CAPM
        capm_exp = rf_rate + beta * (mkt_ret - rf_rate)
        # 2. 4-Factor Proxy (Market, Beta_Bank for Size/Fin, Stock Momentum)
        beta_bank = returns[sel_stock].rolling(len(returns)).corr(returns['^NSEBANK']).iloc[-1]
        mom_factor = returns[sel_stock].tail(252).sum() # 1Y Momentum
        ff_exp = rf_rate + (beta * 0.08) + (beta_bank * 0.03) + (mom_factor * 0.05)
        # 3. APT Proxy
        apt_exp = rf_rate + (beta * 0.09) + (beta_bank * 0.04)

        st.divider()
        v1, v2, v3 = st.columns(3)
        def draw_val(name, exp, actual):
            alpha = actual - exp
            status = "UNDERVALUED" if alpha > 0 else "OVERVALUED"
            v_class = "status-undervalued" if alpha > 0 else "status-overvalued"
            st.markdown(f"""<div class='valuation-card'><small>{name}</small><h3>{exp:.2%}</h3>
                        <p>Alpha: <span class='{v_class}'>{alpha:+.2%}</span></p>
                        <p class='{v_class}'>{status}</p></div>""", unsafe_allow_html=True)
        
        with v1: draw_val("CAPM Expected", capm_exp, avg_ann_ret)
        with v2: draw_val("4-Factor Model", ff_exp, avg_ann_ret)
        with v3: draw_val("APT Model", apt_exp, avg_ann_ret)

    # --- TAB 2 (Kept as per your previous code) ---
    with tab2:
        st.subheader("Price Structure & Trend Analysis")
        # [Tab 2 Logic remains untouched]

    # --- TAB 3: UPDATED STRATEGY LOGIC ---
    with tab3:
        st.header("ðŸ”® Forward Strategy Playbook")
        
        # GARCH Section
        returns_garch = 100 * data[sel_stock].pct_change().dropna()
        am = arch_model(returns_garch, vol='Garch', p=1, q=1, dist='t')
        res = am.fit(disp="off")
        forecast_vol = np.sqrt(res.forecast(horizon=252).variance.values[-1, :]) / 100
        
        # Forecast Logic
        last_p = data[sel_stock].iloc[-1]
        drift = returns_garch.mean() / 100
        np.random.seed(42)
        price_path = [last_p]
        for i in range(252):
            price_path.append(price_path[-1] * np.exp(drift + forecast_vol[i] * np.random.standard_normal()))
        df_forecast = pd.DataFrame({'Close': price_path[1:]}, index=[data.index[-1] + timedelta(days=i) for i in range(1, 253)])

        # STRATEGY SELECTION
        st.subheader("Strategy Configuration")
        strat = st.selectbox("Select Strategy", ["RSI", "SMA Crossover", "Triple Golden Cross"])
        
        def run_strategy_logic(df, s_type):
            df = df.copy()
            if s_type == "RSI":
                p = st.slider("RSI Period", 7, 30, 14)
                st.info("**Logic:** Buying when RSI dips below 30 (Oversold) and selling when it rises above 70 (Overbought). It assumes prices eventually return to their mean.")
                delta = df['Close'].diff()
                gain = (delta.where(delta > 0, 0)).rolling(p).mean()
                loss = (-delta.where(delta < 0, 0)).rolling(p).mean()
                df['RSI'] = 100 - (100 / (1 + (gain/loss)))
                df['Signal'] = np.where(df['RSI'] < 30, 1, 0)
            
            elif s_type == "SMA Crossover":
                f, s = st.columns(2)
                p1 = f.number_input("Fast SMA", value=20)
                p2 = s.number_input("Slow SMA", value=50)
                st.info("**Logic:** Classic momentum tracking. Buy when the Fast average moves above the Slow average, suggesting a trend acceleration.")
                df['SMA_F'] = df['Close'].rolling(p1).mean()
                df['SMA_S'] = df['Close'].rolling(p2).mean()
                df['Signal'] = np.where(df['SMA_F'] > df['SMA_S'], 1, 0)
                
            elif s_type == "Triple Golden Cross":
                t1, t2, t3 = st.columns(3)
                p_s = t1.number_input("Small (Fast)", value=10)
                p_m = t2.number_input("Medium", value=50)
                p_l = t3.number_input("Long (Baseline)", value=200)
                st.info("**Institutional Logic:** Buy only when the Small MA crosses above the Medium MA while *below* the Long-term curve (Early recovery). Sell when Small MA crosses below Medium while *above* the Long-term curve (Trend exhaustion).")
                df['S'] = df['Close'].rolling(p_s).mean()
                df['M'] = df['Close'].rolling(p_m).mean()
                df['L'] = df['Close'].rolling(p_l).mean()
                # Logic: Buy if Small > Medium AND Medium < Long
                df['Signal'] = np.where((df['S'] > df['M']) & (df['M'] < df['L']), 1, 0)
            
            df['Ret'] = df['Close'].pct_change()
            df['Strat_Ret'] = df['Signal'].shift(1) * df['Ret']
            return df

        # Execute
        full_data = pd.concat([data[[sel_stock]].tail(250).rename(columns={sel_stock:'Close'}), df_forecast])
        final_df = run_strategy_logic(full_data, strat).loc[df_forecast.index]

        # OUTPUTS
        c_left, c_right = st.columns([2, 1])
        with c_right:
            st.write("**Forecasted Strategy Metrics**")
            ret = final_df['Strat_Ret'].mean() * 252
            risk = final_df['Strat_Ret'].std() * np.sqrt(252)
            met_df = pd.DataFrame({
                "Metric": ["Return", "Risk", "Sharpe", "Trades"],
                "Value": [f"{ret:.2%}", f"{risk:.2%}", f"{(ret/risk if risk!=0 else 0):.2f}", int(final_df['Signal'].diff().abs().sum())]
            })
            st.table(met_df)

        with c_left:
            fig = go.Figure()
            fig.add_trace(go.Scatter(x=final_df.index, y=final_df['Close'], name="Future Price", line=dict(color='#94a3b8')))
            buys = final_df[final_df['Signal'].diff() == 1]
            sells = final_df[final_df['Signal'].diff() == -1]
            fig.add_trace(go.Scatter(x=buys.index, y=buys['Close'], mode='markers', name='BUY', marker=dict(symbol='triangle-up', size=15, color='green')))
            fig.add_trace(go.Scatter(x=sells.index, y=sells['Close'], mode='markers', name='SELL', marker=dict(symbol='triangle-down', size=15, color='red')))
            st.plotly_chart(fig, use_container_width=True)
    
    







