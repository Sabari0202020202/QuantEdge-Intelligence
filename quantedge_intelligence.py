# -*- coding: utf-8 -*-
"""QuantEdge Intelligence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gkmpljoOIvjbKUjTAM0G8OCGRZI-inXT
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from arch import arch_model
from datetime import datetime, timedelta
from scipy.stats import norm, skew, kurtosis, probplot
from scipy.optimize import fsolve

# --- LIGHT THEME UI & STYLING ---
st.set_page_config(page_title="Sabarimayurnath's 360¬∞ Stock Strategy & Valuation Suite", layout="wide", page_icon="üõ°Ô∏è")

st.markdown("""
<style>
    .stApp { background-color: #f8fafc; color: #1e293b; }
    [data-testid="stMetricValue"] { color: #1e3a8a !important; font-weight: 800; }
    [data-testid="metric-container"] {
        background-color: #ffffff; border: 1px solid #e2e8f0;
        border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .valuation-card {
        padding: 20px; border-radius: 12px; background-color: #ffffff;
        border: 1px solid #e2e8f0; border-top: 4px solid #2563eb;
        margin-bottom: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.07);
    }
    .status-undervalued { color: #16a34a; font-weight: bold; }
    .status-overvalued { color: #dc2626; font-weight: bold; }
    .linkedin-box {
        background-color: #0077b5; color: white !important;
        padding: 12px; border-radius: 8px; text-align: center;
        text-decoration: none; display: block; font-weight: bold; margin-top: 15px;
    }
</style>
""", unsafe_allow_html=True)

# --- SIDEBAR ---
with st.sidebar:
    st.title(" üõ°Ô∏è  QuantPro Intelligence")
    st.markdown("---")
    st.markdown("### **Key Capabilities**")
    st.markdown("""
    * **Visual Analysis:** *Interactive Candlestick, BB, & Volume Charts.*
    * **Multi-Factor Valuation:** *Alpha analysis using CAPM, 4-Factor, and APT.*
    * **Volatility Engine:** *GARCH(1,1), News Impact Curve, & 5-Day Forecasts.*
    * **Strategy Backtester:** *Triple-MA and RSI Simulation with Buy/Sell Signals.*
    * **Market Risk:** *Academic, Historic, & Industry VaR with Period selection.*
    * **Credit Risk:** *Merton/KMV Probability of Default Solver.*
    * **Comparison:** *Multi-stock Ranking & Winner Logic.*
    """)
    st.markdown("---")
    st.markdown("### **Developer Profile**")
    st.markdown("**Name:** *Sabarimayurnath U*")
    st.markdown("**Email:** `u.sabarimayurnath@gmail.com`")
    st.markdown("MBA Finance")
    st.markdown("NMIMS Bengaluru")
    st.markdown(f'<a href="https://www.linkedin.com/in/sabarimayurnath-u/" target="_blank" class="linkedin-box">Connect on LinkedIn</a>', unsafe_allow_html=True)
    st.markdown("---")
    st.caption("¬© 2026 QuantPro Intelligence")

# --- CENTRALIZED DATA ENGINE ---
@st.cache_data(ttl=3600)
def fetch_master_data(ticker, lookback_years):
    start_date = (datetime.now() - timedelta(days=lookback_years*365 + 365)).strftime('%Y-%m-%d')
    data_pkg = {"valid": False, "error": None}

    try:
        # 1. Fetch Stock
        stock_df = yf.download(ticker, start=start_date, progress=False)
        if stock_df.empty:
            data_pkg["error"] = f"No data found for {ticker}"
            return data_pkg
        if isinstance(stock_df.columns, pd.MultiIndex):
            stock_df.columns = stock_df.columns.get_level_values(0)
        
        # 2. Fetch Benchmark (Nifty)
        nifty_df = yf.download("^NSEI", start=start_date, progress=False)
        if isinstance(nifty_df.columns, pd.MultiIndex):
            nifty_df.columns = nifty_df.columns.get_level_values(0)
            
        # 3. Fetch Sector (Bank Nifty)
        bank_df = yf.download("^NSEBANK", start=start_date, progress=False)
        if isinstance(bank_df.columns, pd.MultiIndex):
            bank_df.columns = bank_df.columns.get_level_values(0)

        # 4. Fetch Fundamentals
        t_obj = yf.Ticker(ticker)
        info = t_obj.info
        bs = t_obj.balance_sheet
        
        def get_debt_val(labels):
            for label in labels:
                match = [i for i in bs.index if label.lower() in str(i).lower()]
                if match: return bs.loc[match[0]].iloc[0] / 1e7
            return 0.0

        data_pkg["stock_df"] = stock_df
        data_pkg["nifty_df"] = nifty_df
        data_pkg["bank_df"] = bank_df
        data_pkg["market_cap"] = info.get('marketCap', 0) / 1e7
        data_pkg["total_debt"] = info.get('totalDebt', 0) / 1e7
        data_pkg["st_debt"] = get_debt_val(['Current Debt', 'Short Term Borrowings'])
        data_pkg["lt_debt"] = get_debt_val(['Long Term Debt', 'Long Term Borrowings'])
        
        if data_pkg["total_debt"] == 0:
            data_pkg["total_debt"] = data_pkg["st_debt"] + data_pkg["lt_debt"]
            
        data_pkg["ltp"] = stock_df['Close'].iloc[-1]
        data_pkg["valid"] = True
        
    except Exception as e:
        data_pkg["error"] = str(e)
    return data_pkg

# --- HELPER: Comparison Data ---
def get_simple_data(ticker, start_date):
    try:
        data = yf.download(ticker, start=start_date, progress=False)
        if isinstance(data.columns, pd.MultiIndex):
            data.columns = data.columns.get_level_values(0)
        return data
    except: return pd.DataFrame()

# --- TAB SETUP ---
tab_sel, tab1, tab2, tab3, tab5, tab4, tab6 = st.tabs([
    " üîç Selection", 
    " üíé Analysis & Valuation", 
    " üèóÔ∏è Structure", 
    " üîÆ Strategy", 
    " ‚ö†Ô∏è Market Risk", 
    " üìâ Credit Risk",
    " ‚öñÔ∏è Comparison"
])

# --- TAB 0: SELECTION ---
with tab_sel:
    st.title("Asset Selection & Strategic Parameters")
    sel_mode = st.selectbox("Select Asset", ["RELIANCE.NS", "TCS.NS", "HDFCBANK.NS", "INFY.NS", "SBIN.NS", "TATAMOTORS.NS", "Others"])
    if sel_mode == "Others":
        sel_stock = st.text_input("Enter Yahoo Ticker", "ETERNAL.NS").upper()
    else: sel_stock = sel_mode

    col_s1, col_s2 = st.columns(2)
    with col_s1: lookback_yrs = st.slider("Years of Data", 1, 15, 5)
    with col_s2: rf_rate = st.number_input("Risk Free Rate %", value=7.1) / 100
        
    if st.button("üîÑ Initialize Analytics Engine"):
        st.cache_data.clear()
        st.rerun()

# --- ENGINE START ---
master_data = fetch_master_data(sel_stock, lookback_yrs)

if not master_data["valid"]:
    st.error(f"‚ùå Error: {master_data['error']}")
else:
    df = master_data["stock_df"]
    nifty = master_data["nifty_df"]
    bank_nifty = master_data["bank_df"]
    
    returns = df['Close'].pct_change().dropna()
    if not nifty.empty:
        common_idx = returns.index.intersection(nifty.index)
        returns = returns.loc[common_idx]
        mkt_rets = nifty['Close'].pct_change().dropna().loc[common_idx]
    else:
        mkt_rets = pd.Series(np.random.normal(0, 0.01, len(returns)), index=returns.index)

    ann_ret_raw = returns.mean() * 252
    ann_vol = returns.std() * np.sqrt(252)
    days_hist = (df.index[-1] - df.index[0]).days
    cagr = ((df['Close'].iloc[-1] / df['Close'].iloc[0]) ** (365/days_hist)) - 1

    # --- TAB 1: ANALYSIS & VALUATION ---
    with tab1:
        st.title(f"Analysis & Valuation: {sel_stock}")
        st.write(f"**LTP:** ‚Çπ{master_data['ltp']:,.2f}")

        # 1. Technical Charts
        st.subheader("Price Action & Technicals")
        df['SMA_50'] = df['Close'].rolling(50).mean()
        df['BB_Mid'] = df['Close'].rolling(20).mean()
        df['BB_Std'] = df['Close'].rolling(20).std()
        df['BB_Upper'] = df['BB_Mid'] + 2*df['BB_Std']
        df['BB_Lower'] = df['BB_Mid'] - 2*df['BB_Std']

        fig_candle = go.Figure()
        fig_candle.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Price'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['SMA_50'], line=dict(color='orange', width=1), name='SMA 50'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['BB_Upper'], line=dict(color='gray', width=1, dash='dot'), name='BB Upper'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['BB_Lower'], line=dict(color='gray', width=1, dash='dot'), name='BB Lower'))
        fig_candle.update_layout(height=500, title=f"{sel_stock} Technical Chart")
        st.plotly_chart(fig_candle, use_container_width=True)

        st.subheader("Volume Profile")
        fig_vol = px.bar(df, x=df.index, y='Volume', title="Trading Volume")
        st.plotly_chart(fig_vol, use_container_width=True)

        # 2. Valuation Logic
        st.divider()
        beta = (returns.cov(mkt_rets) * 252) / (mkt_rets.var() * 252)
        capm_exp = rf_rate + beta * (mkt_rets.mean()*252 - rf_rate)
        
        sec_corr = 0.5
        if not bank_nifty.empty:
            b_ret = bank_nifty['Close'].pct_change().dropna()
            idx = returns.index.intersection(b_ret.index)
            if len(idx) > 100: sec_corr = returns.loc[idx].rolling(252).corr(b_ret.loc[idx]).iloc[-1]
            
        ff_exp = rf_rate + (beta * 0.08) + (sec_corr * 0.02)
        apt_exp = capm_exp + 0.015

        st.subheader("Multi-Factor Valuation Alphas")
        v1, v2, v3 = st.columns(3)
        def draw_v(col, name, exp, actual):
            al = actual - exp
            vc = "status-undervalued" if al > 0 else "status-overvalued"
            col.markdown(f"""<div class='valuation-card'><small>{name}</small><h3>Exp: {exp:.2%}</h3>
            <p class='{vc}'>Alpha: {al:+.2%} ({"Undervalued" if al > 0 else "Overvalued"})</p></div>""", unsafe_allow_html=True)
        
        draw_v(v1, "CAPM Model", capm_exp, cagr)
        draw_v(v2, "4-Factor Model", ff_exp, cagr)
        draw_v(v3, "APT Model", apt_exp, cagr)

        # 3. 19-Point Stats
        st.subheader("Advanced Statistics")
        dd = (df['Close'] - df['Close'].cummax()) / df['Close'].cummax()
        metrics = [
            ("Sharpe", (ann_ret_raw-rf_rate)/ann_vol), ("Sortino", (ann_ret_raw-rf_rate)/(returns[returns<0].std()*np.sqrt(252))),
            ("Calmar", ann_ret_raw/abs(dd.min())), ("CAGR", cagr),
            ("Max Drawdown", dd.min()), ("Vol (Ann.)", ann_vol),
            ("VaR (95%)", np.percentile(returns, 5)), ("CVaR (95%)", returns[returns<=np.percentile(returns,5)].mean()),
            ("Skew", skew(returns)), ("Kurtosis", kurtosis(returns)),
            ("Profit Factor", abs(returns[returns>0].sum()/returns[returns<0].sum())), ("Gain/Pain", returns.sum()/abs(returns[returns<0].sum()))
        ]
        
        cols = st.columns(4)
        for i, (k, v) in enumerate(metrics):
            cols[i % 4].metric(k, f"{v:.2%}" if "ratio" not in k.lower() and "factor" not in k.lower() and "skew" not in k.lower() and "kurtosis" not in k.lower() else f"{v:.2f}")

    # --- TAB 2: STRUCTURE ---
    with tab2:
        st.title("Structural DNA")
        ma200 = df['Close'].rolling(200).mean()
        
        c1, c2, c3 = st.columns(3)
        c1.metric("Trend vs 200-MA", "BULLISH" if master_data['ltp'] > ma200.iloc[-1] else "BEARISH")
        c2.metric("52W High Dist", f"{((master_data['ltp']/df['Close'].max())-1):.2%}")
        c3.metric("Support (22D Low)", f"‚Çπ{df['Close'].tail(22).min():.2f}")

        st.subheader("Price Memory (Support/Resistance)")
        fig_sr = go.Figure()
        fig_sr.add_trace(go.Scatter(x=df.tail(252).index, y=df['Close'].tail(252), name="Price"))
        fig_sr.add_hline(y=df['Close'].tail(22).max(), line_dash="dash", line_color="green", annotation_text="Res")
        fig_sr.add_hline(y=df['Close'].tail(22).min(), line_dash="dash", line_color="red", annotation_text="Sup")
        st.plotly_chart(fig_sr, use_container_width=True)

    # --- TAB 3: STRATEGY (UPDATED) ---
    with tab3:
        st.title("GARCH Volatility & Strategy Backtester")
        ret_g = 100 * returns
        am = arch_model(ret_g, vol='Garch', p=1, q=1, dist='t')
        res_g = am.fit(disp="off")

        # 1. Plots: Volatility & NIC
        c1, c2 = st.columns(2)
        with c1:
            st.subheader("Conditional Volatility")
            fig_v = go.Figure()
            fig_v.add_trace(go.Scatter(x=res_g.conditional_volatility.index, y=res_g.conditional_volatility, line=dict(color='orange')))
            st.plotly_chart(fig_v, use_container_width=True)
        
        with c2:
            st.subheader("News Impact Curve")
            params = res_g.params
            nic_x = np.linspace(ret_g.min(), ret_g.max(), 100)
            nic_y = params['omega'] + params['alpha[1]']*(nic_x**2) + params['beta[1]']*res_g.conditional_volatility.var()
            fig_nic = go.Figure(go.Scatter(x=nic_x, y=nic_y, line=dict(color='firebrick')))
            st.plotly_chart(fig_nic, use_container_width=True)

        # 2. Backtester with Inputs & Summary
        st.divider()
        st.subheader("Strategy Simulation (1-Year Forecast)")
        
        strat_col1, strat_col2 = st.columns([1, 2])
        with strat_col1:
            strat = st.selectbox("Strategy Methodology", ["Triple Golden Cross", "RSI", "SMA Crossover"])
            if strat == "Triple Golden Cross":
                s_p = st.number_input("Short MA", 10)
                m_p = st.number_input("Mid MA", 50)
                l_p = st.number_input("Long MA", 200)
            elif strat == "RSI":
                r_p = st.slider("RSI Period", 7, 30, 14)
            else:
                s_sma = st.number_input("Fast MA", 20)
                l_sma = st.number_input("Slow MA", 50)

        # Simulation
        sim_vol = np.sqrt(res_g.forecast(horizon=252).variance.values[-1, :])/100
        sim_p = [master_data['ltp']]
        np.random.seed(42)
        for i in range(252): sim_p.append(sim_p[-1]*np.exp(returns.mean() + sim_vol[i]*np.random.normal()))
        
        df_f = pd.DataFrame({'Close': sim_p[1:]}, index=[df.index[-1]+timedelta(days=i) for i in range(1, 253)])
        
        # Signal Logic
        if strat == "Triple Golden Cross":
            df_f['S'], df_f['M'], df_f['L'] = df_f['Close'].rolling(s_p).mean(), df_f['Close'].rolling(m_p).mean(), df_f['Close'].rolling(l_p).mean()
            df_f['Signal'] = np.where((df_f['S']>df_f['M']) & (df_f['S']<df_f['L']), 1, 0)
        elif strat == "RSI":
            delta = df_f['Close'].diff()
            g, l = delta.where(delta>0,0).rolling(r_p).mean(), -delta.where(delta<0,0).rolling(r_p).mean()
            df_f['RSI'] = 100 - (100/(1+(g/l)))
            df_f['Signal'] = np.where(df_f['RSI']<30, 1, 0)
        else:
            df_f['Signal'] = np.where(df_f['Close'].rolling(s_sma).mean()>df_f['Close'].rolling(l_sma).mean(), 1, 0)
            
        # Summary Table
        s_ret_fore = df_f['Signal'].shift(1) * df_f['Close'].pct_change()
        st.write("#### Performance Summary")
        sum_df = pd.DataFrame({
            "Metric": ["Annualized Return", "Annualized Risk", "Sharpe Ratio", "No. of Trades"],
            "Value": [
                f"{s_ret_fore.mean()*252:.2%}",
                f"{s_ret_fore.std()*np.sqrt(252):.2%}",
                f"{(s_ret_fore.mean()*252)/(s_ret_fore.std()*np.sqrt(252)):.2f}" if s_ret_fore.std() != 0 else "0.00",
                f"{int(df_f['Signal'].diff().abs().sum()/2)}"
            ]
        })
        st.table(sum_df)

        # Forecast Graph with Markers
        fig_sim = go.Figure()
        fig_sim.add_trace(go.Scatter(x=df_f.index, y=df_f['Close'], name='Forecast Price', line=dict(color='gray', width=1)))
        
        buys = df_f[df_f['Signal'].diff()==1]
        sells = df_f[df_f['Signal'].diff()==-1]
        
        fig_sim.add_trace(go.Scatter(x=buys.index, y=buys['Close'], mode='markers', marker=dict(symbol='triangle-up', size=12, color='green'), name='BUY Signal'))
        fig_sim.add_trace(go.Scatter(x=sells.index, y=sells['Close'], mode='markers', marker=dict(symbol='triangle-down', size=12, color='red'), name='SELL Signal'))
        
        st.plotly_chart(fig_sim, use_container_width=True)

    # --- TAB 5: MARKET RISK (UPDATED) ---
    with tab5:
        st.title("‚ö†Ô∏è Market Risk Analysis")
        
        # Inputs for VaR
        st.subheader("VaR Configuration")
        mr_c1, mr_c2 = st.columns(2)
        conf_level = mr_c1.selectbox("Confidence Level", [0.90, 0.95, 0.99], index=1)
        time_pd = mr_c2.number_input("Time Horizon", min_value=1, value=10)
        time_unit = mr_c2.selectbox("Unit", ["Days", "Weeks", "Months"])
        
        # Scaling Factor
        t_days = time_pd * (5 if time_unit=="Weeks" else 21 if time_unit=="Months" else 1)
        scale_f = np.sqrt(t_days)
        
        # Calculate VaRs
        mu = returns.mean() * t_days
        sigma = returns.std() * scale_f
        
        # 1. Academic (Parametric Normal)
        var_academic = norm.ppf(1-conf_level, mu, sigma)
        
        # 2. Historical
        hist_loss = returns * np.sqrt(t_days) # Simple approximation for historical scaling
        var_historic = np.percentile(hist_loss, (1-conf_level)*100)
        
        # 3. CVaR (Expected Shortfall)
        cvar_val = hist_loss[hist_loss <= var_historic].mean()
        
        # 4. Industry (Modified/Cornish-Fisher)
        z = norm.ppf(1-conf_level)
        s = skew(returns)
        k = kurtosis(returns)
        z_mod = z + (z**2 - 1)*s/6 + (z**3 - 3*z)*(k-3)/24 - (2*z**3 - 5*z)*(s**2)/36
        var_industry = mu + z_mod*sigma

        # Display Metrics
        st.subheader(f"Risk Metrics ({time_pd} {time_unit} @ {conf_level:.0%})")
        m1, m2, m3, m4 = st.columns(4)
        m1.metric("Academic VaR (Normal)", f"{var_academic:.2%}")
        m2.metric("Historical VaR", f"{var_historic:.2%}")
        m3.metric("CVaR (Expected Shortfall)", f"{cvar_val:.2%}")
        m4.metric("Modified VaR (Industry)", f"{var_industry:.2%}")

        # Charts
        st.divider()
        c1, c2 = st.columns(2)
        with c1:
            st.subheader("Return Distribution & VaR Cutoff")
            fig_dist = px.histogram(hist_loss, nbins=50, title="Projected Loss Distribution")
            fig_dist.add_vline(x=var_historic, line_color="red", line_dash="dash", annotation_text="VaR")
            st.plotly_chart(fig_dist, use_container_width=True)
            
        with c2:
            st.subheader("Rolling Beta (60D)")
            cov = returns.rolling(60).cov(mkt_rets)
            beta_roll = cov / mkt_rets.rolling(60).var()
            st.line_chart(beta_roll)

    # --- TAB 4: CREDIT RISK (FULLY RESTORED) ---
    with tab4:
        st.title("üõ°Ô∏è Credit Risk (Merton/KMV Model)")
        st.table(pd.DataFrame({
            "Component": ["ST Debt", "LT Debt", "Total Debt", "Market Cap"],
            "Value (Cr ‚Çπ)": [
                f"{master_data['st_debt']:,.2f}", 
                f"{master_data['lt_debt']:,.2f}", 
                f"{master_data['total_debt']:,.2f}", 
                f"{master_data['market_cap']:,.2f}"
            ]
        }))

        m_frame = st.radio("Model Framework", ["Merton Model", "KMV Model"])
        
        # Determine Default Barrier
        if m_frame == "KMV Model":
            barr = master_data['st_debt'] + 0.5 * master_data['lt_debt']
        else:
            barr = master_data['total_debt']
            
        barr = st.number_input("Final Default Barrier (Threshold)", value=float(barr) if barr > 0 else 5000.0)

        def solve_m(E, se, L, r, T):
            def eq(p):
                V, sv = p; d1 = (np.log(V/L) + (r + 0.5 * sv**2) * T) / (sv * np.sqrt(T));
                d2 = d1 - sv * np.sqrt(T)
                return [V * norm.cdf(d1) - L * np.exp(-r * T) * norm.cdf(d2) - E, (norm.cdf(d1) * V / E) * sv - se]
            return fsolve(eq, [E + L, se * (E / (E + L))])
        
        try:
            if barr > 0 and master_data['market_cap'] > 0:
                va, sa = solve_m(master_data['market_cap'], ann_vol, barr, rf_rate, 1.0)
                dd_v = (np.log(va/barr) + (rf_rate - 0.5 * sa**2)) / sa
                pd_v = norm.cdf(-dd_v)
                
                c_c1, c_c2, c_c3, c_c4 = st.columns(4)
                c_c1.metric("Distance to Default", f"{dd_v:.2f} œÉ")
                c_c2.metric("Prob. of Default", f"{pd_v:.4%}")
                c_c3.metric("Implied Asset Value", f"‚Çπ{va:,.0f} Cr")
                c_c4.metric("Implied Asset Vol", f"{sa:.2%}")
                
                st.divider()
                st.write(f"**Interpretation:** The firm is **{dd_v:.2f} standard deviations** away from default. A Distance-to-Default (DD) below 1.5œÉ typically signals financial distress.")
            else:
                st.warning("Insufficient Debt/Equity data for Credit Risk Model.")
        except: 
            st.error("Solver Error: Financial ratios are too extreme for convergence.")
    # --- TAB 6: COMPARISON (Updated) ---
    with tab6:
        st.title("‚öñÔ∏è Multi-Stock Comparison")
        comp_str = st.text_input("Tickers (comma sep)", "RELIANCE.NS, TCS.NS, HDFCBANK.NS")
        
        if st.button("Compare Peers"):
            tickers = [x.strip() for x in comp_str.split(',')]
            
            # Lists to store data for different purposes
            raw_metrics = [] # For calculations and charts
            display_data = [] # For the formatted table
            
            # DataFrame for Cumulative Returns Chart
            cum_ret_df = pd.DataFrame()
            
            start_dt = (datetime.now()-timedelta(days=lookback_yrs*365)).strftime('%Y-%m-%d')
            
            progress_bar = st.progress(0)
            
            for i, t in enumerate(tickers):
                d = get_simple_data(t, start_dt)
                if not d.empty:
                    # Calculations
                    ret = d['Close'].pct_change().dropna()
                    days = (d.index[-1] - d.index[0]).days
                    years = days / 365.25
                    
                    # 1. Annualized Return (CAGR)
                    total_ret = (d['Close'].iloc[-1] / d['Close'].iloc[0])
                    cagr = (total_ret ** (1/years)) - 1
                    
                    # 2. Annualized Volatility
                    vol = ret.std() * np.sqrt(252)
                    
                    # 3. Sharpe Ratio
                    sharpe = (cagr - rf_rate) / vol if vol != 0 else 0
                    
                    # 4. Max Drawdown
                    dd = (d['Close'] - d['Close'].cummax()) / d['Close'].cummax()
                    max_dd = dd.min()
                    
                    # Store Raw (for logic/charts)
                    raw_metrics.append({
                        "Ticker": t,
                        "Ann. Return": cagr,
                        "Ann. Risk": vol,
                        "Sharpe": sharpe,
                        "Max DD": max_dd
                    })
                    
                    # Store Formatted (for display)
                    display_data.append({
                        "Ticker": t,
                        "Ann. Return (%)": f"{cagr*100:.2f}",
                        "Ann. Risk (%)": f"{vol*100:.2f}",
                        "Sharpe Ratio": f"{sharpe:.2f}",
                        "Max Drawdown (%)": f"{max_dd*100:.2f}"
                    })
                    
                    # Add to Cumulative Returns DF (Normalized to 100)
                    cum_ret_df[t] = (d['Close'] / d['Close'].iloc[0]) * 100
                
                progress_bar.progress((i + 1) / len(tickers))
            
            # --- 1. TABLE GENERATION ---
            if raw_metrics:
                # Convert raw metrics to DF for "Winner" calculation
                df_raw = pd.DataFrame(raw_metrics).set_index("Ticker")
                
                # Determine Winners
                winners = {}
                for col in df_raw.columns:
                    if col in ["Ann. Risk", "Max DD"]:
                        # For Risk/Drawdown, Lower is Better (Note: Max DD is negative, so Max value (closest to 0) is better)
                        if col == "Max DD":
                             win_ticker = df_raw[col].idxmax() # Closest to 0 (e.g., -0.1 is better than -0.5)
                        else:
                             win_ticker = df_raw[col].idxmin() # Lowest Volatility
                    else:
                        # For Return/Sharpe, Higher is Better
                        win_ticker = df_raw[col].idxmax()
                    winners[col] = win_ticker

                # Create Display DataFrame
                df_disp = pd.DataFrame(display_data).set_index("Ticker")
                
                # Map raw column names to display column names for the winner row
                col_map = {
                    "Ann. Return": "Ann. Return (%)",
                    "Ann. Risk": "Ann. Risk (%)",
                    "Sharpe": "Sharpe Ratio",
                    "Max DD": "Max Drawdown (%)"
                }
                
                winner_row = {col_map[k]: v for k, v in winners.items()}
                
                # Append Winner Row
                df_disp.loc['üèÜ WINNER'] = pd.Series(winner_row)
                
                st.subheader("Performance Matrix")
                st.table(df_disp)
                
                # --- 2. CHARTS ---
                st.divider()
                col_c1, col_c2 = st.columns(2)
                
                with col_c1:
                    st.subheader("Cumulative Returns (Rebased to 100)")
                    fig_cum = px.line(cum_ret_df, x=cum_ret_df.index, y=cum_ret_df.columns, 
                                      labels={"value": "Value (Rebased)", "index": "Date", "variable": "Ticker"})
                    st.plotly_chart(fig_cum, use_container_width=True)
                    
                with col_c2:
                    st.subheader("Risk-Adjusted Return (Sharpe)")
                    # Sort by Sharpe for better visualization
                    df_raw_sorted = df_raw.sort_values(by="Sharpe", ascending=False).reset_index()
                    fig_sharpe = px.bar(df_raw_sorted, x="Ticker", y="Sharpe", color="Ticker", 
                                        text_auto='.2f', title="Sharpe Ratio Comparison")
                    fig_sharpe.update_layout(showlegend=False)
                    st.plotly_chart(fig_sharpe, use_container_width=True)
            else:
                st.error("No valid data found for the selected tickers.")  


                # --- 3. ADVANCED COMPARISON VISUALS ---
                st.divider()
                st.subheader("üß© Diversification & Risk Architecture")
                
                # Prepare Data for Correlation & Drawdowns
                all_rets = cum_ret_df.pct_change().dropna()
                
                col_d1, col_d2 = st.columns(2)
                
                with col_d1:
                    st.markdown("**Correlation Matrix** (Light = High Corr, Dark = Low Corr)")
                    corr_matrix = all_rets.corr()
                    fig_corr = px.imshow(corr_matrix, text_auto=".2f", aspect="auto", color_continuous_scale="Blues")
                    st.plotly_chart(fig_corr, use_container_width=True)
                    
                with col_d2:
                    st.markdown("**Risk-Return Scatter** (Top-Left is Ideal)")
                    fig_scat = px.scatter(df_raw, x="Ann. Risk", y="Ann. Return", color="Ticker", 
                                          text="Ticker", size=[10]*len(df_raw), 
                                          labels={"Ann. Risk": "Annualized Risk (Volatility)", "Ann. Return": "Annualized Return (CAGR)"})
                    fig_scat.update_traces(textposition='top center')
                    # Add reference lines for average
                    fig_scat.add_vline(x=df_raw["Ann. Risk"].mean(), line_dash="dot", line_color="gray", annotation_text="Avg Risk")
                    fig_scat.add_hline(y=df_raw["Ann. Return"].mean(), line_dash="dot", line_color="gray", annotation_text="Avg Return")
                    st.plotly_chart(fig_scat, use_container_width=True)

                # Drawdown Comparison Chart
                st.subheader("üåä Drawdown Profile (Depth of Losses)")
                # Calculate Drawdowns for all
                dd_df = pd.DataFrame()
                for col in cum_ret_df.columns:
                    # Reconstruct raw prices from normalized data for DD calc (math is same)
                    dd_df[col] = (cum_ret_df[col] - cum_ret_df[col].cummax()) / cum_ret_df[col].cummax()
                
                fig_dd = px.area(dd_df, x=dd_df.index, y=dd_df.columns, 
                                 labels={"value": "Drawdown %", "variable": "Ticker"}, title="Historical Drawdowns")
                fig_dd.update_yaxes(tickformat=".1%")
                st.plotly_chart(fig_dd, use_container_width=True)     
