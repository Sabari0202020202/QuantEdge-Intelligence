# -*- coding: utf-8 -*-
"""QuantEdge Intelligence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gkmpljoOIvjbKUjTAM0G8OCGRZI-inXT
"""

!pip install -q streamlit

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime
from scipy.stats import norm

# --- PAGE CONFIG ---
st.set_page_config(page_title="QuantEdge India", layout="wide", initial_sidebar_state="expanded")

# Custom CSS for "Not Dull" UI
st.markdown("""
    <style>
    .main { background-color: #0e1117; }
    div.stButton > button:first-child { background-color: #00ffcc; color: black; }
    h1, h2, h3 { color: #00ffcc !important; }
    .stMetric { background-color: #161b22; border-radius: 10px; padding: 15px; border: 1px solid #30363d; }
    </style>
    """, unsafe_allow_html=True)

# --- SIDEBAR CONTROLS ---
st.sidebar.header("ðŸ› ï¸ Strategy Controls")
ticker_input = st.sidebar.text_input("Enter NSE/BSE Ticker (e.g., RELIANCE.NS, TCS.NS)", "RELIANCE.NS")
risk_free_rate = st.sidebar.slider("Risk Free Rate (%)", 0.0, 10.0, 6.0) / 100
capital = st.sidebar.number_input("Trading Capital (â‚¹)", value=1000000)
risk_per_trade = st.sidebar.slider("Risk per Trade (%)", 0.1, 5.0, 1.0) / 100

# --- DATA ENGINE ---
@st.cache_data
def load_data(ticker):
    data = yf.download(ticker, start="2000-01-01")
    if data.empty: return None
    data.columns = [c[0] if isinstance(c, tuple) else c for c in data.columns] # Fix for multi-index
    return data

data = load_data(ticker_input)

if data is not None:
    # Calculations
    data['Returns'] = data['Close'].pct_change()
    data['Log_Ret'] = np.log(data['Close'] / data['Close'].shift(1))

    # 1. MARKET DNA (Regime Detection)
    window = 20
    data['SMA20'] = data['Close'].rolling(window).mean()
    data['Std'] = data['Close'].rolling(window).std()
    # Rolling R-squared for Trend Strength
    def get_r2(x):
        y = np.array(x)
        x_axis = np.arange(len(y))
        slope, intercept = np.polyfit(x_axis, y, 1)
        r_squared = 1 - (np.sum((y - (slope * x_axis + intercept))**2) / ((len(y) - 1) * np.var(y)))
        return r_squared

    data['Trend_Strength'] = data['Close'].rolling(window).apply(get_r2)

    # --- HEADER ---
    st.title(f"ðŸ“Š QuantEdge Intelligence: {ticker_input}")

    # --- MODULE 1: REGIME & ANOMALIES ---
    col1, col2 = st.columns([2, 1])

    with col1:
        st.subheader("Market DNA & Price Action")
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=data.index, y=data['Close'], name="Price", line=dict(color='#00ffcc')))
        fig.add_trace(go.Scatter(x=data.index, y=data['SMA20'], name="20d SMA", line=dict(dash='dash', color='gray')))
        fig.update_layout(template="plotly_dark", height=400, margin=dict(l=0,r=0,b=0,t=0))
        st.plotly_chart(fig, use_container_width=True)

    with col2:
        st.subheader("Live Regime")
        current_r2 = data['Trend_Strength'].iloc[-1]
        vol = data['Returns'].rolling(20).std().iloc[-1] * np.sqrt(252)

        if current_r2 > 0.7: regime = "ðŸš€ Strong Trend"
        elif current_r2 < 0.3: regime = "ðŸ“‰ Mean Reverting / Choppy"
        else: regime = "âš–ï¸ Transitional"

        st.metric("Detected Regime", regime)
        st.metric("Annualized Volatility", f"{vol:.2%}")

        # Rare Event Detection (Z-Score)
        z_score = (data['Returns'].iloc[-1] - data['Returns'].rolling(100).mean().iloc[-1]) / data['Returns'].rolling(100).std().iloc[-1]
        if abs(z_score) > 2:
            st.error(f"âš ï¸ ANOMALY DETECTED: {z_score:.2f}Ïƒ Move")
        else:
            st.success("Normal Price Distribution")

    # --- MODULE 2: POSITION SIZING ENGINE ---
    st.divider()
    st.subheader("âš¡ Smart Position Sizing (Kelly & ATR)")
    c1, c2, c3 = st.columns(3)

    # Simplified Kelly (Win Rate vs Win/Loss Ratio)
    win_rate = 0.45 # Conservative estimate
    w_l_ratio = 2.0
    kelly_f = win_rate - ((1 - win_rate) / w_l_ratio)

    # ATR Sizing
    high_low = data['High'] - data['Low']
    high_cp = np.abs(data['High'] - data['Close'].shift())
    low_cp = np.abs(data['Low'] - data['Close'].shift())
    df_atr = pd.concat([high_low, high_cp, low_cp], axis=1)
    true_range = np.max(df_atr, axis=1)
    atr = true_range.rolling(14).mean().iloc[-1]

    risk_amt = capital * risk_per_trade
    units = int(risk_amt / (atr * 2)) # Using 2*ATR as stop loss

    c1.metric("Kelly Fraction (Half)", f"{kelly_f/2:.2%}")
    c2.metric("ATR Based Stop (2x)", f"â‚¹{atr*2:.2f}")
    c3.metric("Recommended Units", f"{units} Shares", delta=f"â‚¹{units*data['Close'].iloc[-1]:,.0f} Exposure")

    # --- MODULE 3: PROBABILITY FORECASTER ---
    st.divider()
    st.subheader("ðŸ”® Mean Reversion & Breakout Probabilities")

    last_price = data['Close'].iloc[-1]
    ma_20 = data['SMA20'].iloc[-1]
    dist_from_ma = (last_price - ma_20) / data['Std'].iloc[-1]

    # Probability of returning to mean (simplified Gaussian)
    prob_reversion = norm.cdf(abs(dist_from_ma))

    # Breakout Prob (20-day high)
    high_20 = data['High'].rolling(20).max().iloc[-1]
    dist_to_high = (high_20 - last_price) / last_price

    p1, p2 = st.columns(2)
    p1.write(f"**Reversal Likelihood:** {prob_reversion:.1%}")
    p1.progress(prob_reversion)
    p2.write(f"**Distance to 20D High:** {dist_to_high:.2%}")
    p2.progress(min(1.0, max(0.0, 1 - dist_to_high)))

    # --- MODULE 4: STRATEGY BACKTESTER ---
    st.divider()
    st.subheader("ðŸ§ª Signal Quality Backtest (SMA Crossover)")

    fast_ma = st.slider("Fast SMA", 5, 50, 20)
    slow_ma = st.slider("Slow SMA", 20, 200, 50)

    df_bt = data[['Close']].copy()
    df_bt['Fast'] = df_bt['Close'].rolling(fast_ma).mean()
    df_bt['Slow'] = df_bt['Close'].rolling(slow_ma).mean()
    df_bt['Signal'] = np.where(df_bt['Fast'] > df_bt['Slow'], 1, 0)
    df_bt['Strategy_Ret'] = df_bt['Signal'].shift(1) * data['Returns']

    cum_bench = (1 + data['Returns']).prod() - 1
    cum_strat = (1 + df_bt['Strategy_Ret']).prod() - 1

    b1, b2, b3 = st.columns(3)
    b1.metric("Strategy Return", f"{cum_strat:.2%}")
    b2.metric("Benchmark Return", f"{cum_bench:.2%}")

    # Rolling Returns Chart
    fig_bt = go.Figure()
    fig_bt.add_trace(go.Scatter(x=df_bt.index, y=(1+df_bt['Strategy_Ret']).cumprod(), name="Strategy", line=dict(color="#00ffcc")))
    fig_bt.add_trace(go.Scatter(x=df_bt.index, y=(1+data['Returns']).cumprod(), name="Buy & Hold", line=dict(color="gray")))
    fig_bt.update_layout(template="plotly_dark", title="Cumulative Growth (â‚¹1 Base)")
    st.plotly_chart(fig_bt, use_container_width=True)

else:
    st.error("Ticker not found. Please use '.NS' for National Stock Exchange (e.g., SBIN.NS)")