# -*- coding: utf-8 -*-
"""QuantEdge Intelligence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gkmpljoOIvjbKUjTAM0G8OCGRZI-inXT
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from arch import arch_model
from datetime import datetime, timedelta
from scipy.stats import norm
from scipy.optimize import fsolve

# --- LIGHT THEME UI ---
st.set_page_config(page_title="QuantPro Advisor", layout="wide")
st.markdown("""
    <style>
    .stApp { background-color: #f8fafc; color: #1e293b; }
    [data-testid="stMetricValue"] { color: #1e3a8a !important; font-weight: 800; }
    [data-testid="metric-container"] { 
        background-color: #ffffff; border: 1px solid #e2e8f0; 
        border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .valuation-card { 
        padding: 20px; border-radius: 12px; background-color: #ffffff; 
        border: 1px solid #e2e8f0; border-top: 4px solid #2563eb; 
        margin-bottom: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.07);
    }
    .status-undervalued { color: #16a34a; font-weight: bold; }
    .status-overvalued { color: #dc2626; font-weight: bold; }
    </style>
    """, unsafe_allow_html=True)

# --- ASSET UNIVERSE ---
NIFTY_50 = {
    "RELIANCE.NS": "Reliance Industries", "TCS.NS": "TCS", "HDFCBANK.NS": "HDFC Bank",
    "INFY.NS": "Infosys", "ICICIBANK.NS": "ICICI Bank", "SBIN.NS": "SBI",
    "BHARTIARTL.NS": "Bharti Airtel", "TATAMOTORS.NS": "Tata Motors", "TITAN.NS": "Titan",
    "Others": "Custom Ticker"
}

# --- SIDEBAR CONTROLS ---
st.sidebar.title("üõ†Ô∏è Global Settings")
sel_mode = st.sidebar.selectbox("Select Asset", list(NIFTY_50.keys()))
if sel_mode == "Others":
    sel_stock = st.sidebar.text_input("Enter Yahoo Finance Code", "ETERNAL.NS").upper()
else:
    sel_stock = sel_mode

lookback = st.sidebar.slider("Timeframe (Years)", 1, 15, 5)
rf_rate = st.sidebar.number_input("Risk Free Rate %", value=7.1) / 100

# --- DATA ENGINE ---
@st.cache_data
def get_full_data(ticker, yrs):
    start = datetime.now() - timedelta(days=yrs*365 + 365) 
    df = yf.download([ticker, "^NSEI", "^NSEBANK"], start=start.strftime('%Y-%m-%d'))['Close']
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(1)
    df = df.dropna(subset=[ticker]).ffill()
    return df, df.index[0]

data, listing_date = get_full_data(sel_stock, lookback)

if data is not None:
    tab1, tab2, tab3, tab4 = st.tabs(["üíé Valuation", "üèóÔ∏è Structure", "üîÆ Strategy", "üìâ Credit Risk"])

    # --- TAB 1: VALUATION & PERFORMANCE ---
    with tab1:
        st.title(f"Valuation Engine: {sel_stock}")
        returns = data[sel_stock].pct_change().dropna()
        mkt_rets = data["^NSEI"].pct_change().dropna()
        
        avg_ann_ret = returns.mean() * 252
        ann_risk = returns.std() * np.sqrt(252)
        sharpe = (avg_ann_ret - rf_rate) / ann_risk if ann_risk != 0 else 0
        
        m1, m2, m3 = st.columns(3)
        m1.metric("Avg Annual Return", f"{avg_ann_ret:.2%}")
        m2.metric("Annualized Risk", f"{ann_risk:.2%}")
        m3.metric("Sharpe Ratio", f"{sharpe:.2f}")

        # Multi-Model Logic
        beta = (returns.cov(mkt_rets) * 252) / (mkt_rets.var() * 252)
        mkt_ann_ret = mkt_rets.mean() * 252
        
        capm_exp = rf_rate + beta * (mkt_ann_ret - rf_rate)
        # 4-Factor (Market, Bank Proxy for Size/Financials, 1Y Momentum)
        beta_bank = returns.rolling(252).corr(data['^NSEBANK'].pct_change()).iloc[-1]
        mom_factor = returns.tail(252).sum()
        ff_exp = rf_rate + (beta * 0.08) + (beta_bank * 0.02) + (mom_factor * 0.04)
        apt_exp = rf_rate + (beta * 0.09) + (beta_bank * 0.03)

        st.divider()
        v1, v2, v3 = st.columns(3)
        def draw_val_card(name, exp, actual):
            alpha = actual - exp
            v_class = "status-undervalued" if alpha > 0 else "status-overvalued"
            st.markdown(f"""<div class='valuation-card'><small>{name}</small><h3>Exp: {exp:.2%}/yr</h3>
                        <p>Alpha: <span class='{v_class}'>{alpha:+.2%}</span></p>
                        <p class='{v_class}'>{"UNDERVALUED" if alpha > 0 else "OVERVALUED"}</p></div>""", unsafe_allow_html=True)
        with v1: draw_val_card("CAPM Model", capm_exp, avg_ann_ret)
        with v2: draw_val_card("4-Factor Model", ff_exp, avg_ann_ret)
        with v3: draw_val_card("APT Model", apt_exp, avg_ann_ret)

        # Performance Graph
        cum_ret = (1 + returns).cumprod()
        fig_cum = go.Figure()
        fig_cum.add_trace(go.Scatter(x=cum_ret.index, y=cum_ret, name="Stock", line=dict(color='#2563eb', width=3)))
        fig_cum.add_trace(go.Scatter(x=cum_ret.index, y=(1+mkt_rets).cumprod(), name="Nifty 50", line=dict(color='#94a3b8', dash='dot')))
        st.plotly_chart(fig_cum, use_container_width=True)
        

    # --- TAB 2: STRUCTURAL DNA ---
    with tab2:
        st.title("Price Structure & Technical DNA")
        data['MA50'] = data[sel_stock].rolling(50).mean()
        data['MA200'] = data[sel_stock].rolling(200).mean()
        last_p = data[sel_stock].iloc[-1]

        c1, c2, c3 = st.columns(3)
        with c1: st.metric("Trend vs 200-MA", "‚úÖ BULLISH" if last_p > data['MA200'].iloc[-1] else "‚ùå BEARISH")
        with c2: st.metric("50/200 MA Cross", "üî• GOLDEN" if data['MA50'].iloc[-1] > data['MA200'].iloc[-1] else "‚ùÑÔ∏è DEATH")
        with c3: st.metric("Dist. 52W High", f"{((last_p / data[sel_stock].max()) - 1):.2%}")

        # Support/Resistance Logic
        res = data[sel_stock].tail(22).max(); supp = data[sel_stock].tail(22).min()
        fig_sr = go.Figure()
        fig_sr.add_trace(go.Scatter(x=data.tail(252).index, y=data[sel_stock].tail(252), name="Price", line=dict(color='#1e3a8a')))
        fig_sr.add_hline(y=res, line_dash="dash", line_color="green", annotation_text="Resistance")
        fig_sr.add_hline(y=supp, line_dash="dash", line_color="red", annotation_text="Support")
        st.plotly_chart(fig_sr, use_container_width=True)

        # Relative Strength
        rs = (data[sel_stock].iloc[-1]/data[sel_stock].iloc[-22]) - (data['^NSEI'].iloc[-1]/data['^NSEI'].iloc[-22])
        st.metric("Relative Strength (1M) vs Nifty", f"{rs:+.2%}")
        
        # Drawdown
        dd = (data[sel_stock] - data[sel_stock].cummax()) / data[sel_stock].cummax()
        st.metric("Max Period Drawdown", f"{dd.min():.2%}")
        

    # --- TAB 3: GARCH & STRATEGY ---
    with tab3:
        st.title("Forward Playbook & Volatility Forecast")
        ret_g = 100 * data[sel_stock].pct_change().dropna()
        am = arch_model(ret_g, vol='Garch', p=1, q=1, dist='t')
        res_g = am.fit(disp="off")
        f_vol = np.sqrt(res_g.forecast(horizon=252).variance.values[-1, :]) / 100
        
        # Price Simulation
        np.random.seed(42)
        p_path = [data[sel_stock].iloc[-1]]
        drift = ret_g.mean() / 100
        for i in range(252): p_path.append(p_path[-1] * np.exp(drift + f_vol[i] * np.random.standard_normal()))
        df_f = pd.DataFrame({'Close': p_path[1:]}, index=[data.index[-1] + timedelta(days=i) for i in range(1, 253)])

        strat = st.selectbox("Methodology", ["RSI", "SMA Crossover", "Triple Golden Cross"])
        
        def run_backtest(df, s):
            df = df.copy()
            if s == "RSI":
                p = st.slider("RSI Period", 7, 30, 14)
                st.info("RSI Mean Reversion: Buying oversold (<30), selling overbought (>70).")
                delta = df['Close'].diff(); g = (delta.where(delta > 0, 0)).rolling(p).mean(); l = (-delta.where(delta < 0, 0)).rolling(p).mean()
                df['RSI'] = 100 - (100 / (1 + (g/l))); df['Signal'] = np.where(df['RSI'] < 30, 1, 0)
            elif s == "SMA Crossover":
                p1 = st.number_input("Fast SMA", 20); p2 = st.number_input("Slow SMA", 50)
                df['F'] = df['Close'].rolling(p1).mean(); df['S'] = df['Close'].rolling(p2).mean(); df['Signal'] = np.where(df['F'] > df['S'], 1, 0)
            elif s == "Triple Golden Cross":
                ps, pm, pl = st.columns(3); s_p = ps.number_input("Short", 10); m_p = pm.number_input("Mid", 50); l_p = pl.number_input("Long", 200)
                st.info("Cluster Logic: Buy when Small crosses Mid from below while below Long Curve.")
                df['MS'], df['MM'], df['ML'] = df['Close'].rolling(s_p).mean(), df['Close'].rolling(m_p).mean(), df['Close'].rolling(l_p).mean()
                df['Signal'] = 0
                buy_c = (df['MS'] > df['MM']) & (df['MS'].shift(1) < df['MM'].shift(1)) & (df['MS'] < df['ML'])
                sell_c = (df['MS'] < df['MM']) & (df['MS'].shift(1) > df['MM'].shift(1)) & (df['MS'] > df['ML'])
                curr = 0
                for i in range(len(df)):
                    if buy_c.iloc[i]: curr = 1
                    elif sell_c.iloc[i]: curr = 0
                    df.iloc[i, df.columns.get_loc('Signal')] = curr
            df['Strat_Ret'] = df['Signal'].shift(1) * df['Close'].pct_change()
            return df

        res_bt = run_backtest(pd.concat([data[[sel_stock]].tail(252).rename(columns={sel_stock:'Close'}), df_f]), strat).loc[df_f.index]
        st.table(pd.DataFrame({"Metric": ["Return", "Risk", "Sharpe", "Trades"], "Value": [f"{(res_bt['Strat_Ret'].mean()*252):.2%}", f"{(res_bt['Strat_Ret'].std()*np.sqrt(252)):.2%}", f"{(res_bt['Strat_Ret'].mean()*252)/(res_bt['Strat_Ret'].std()*np.sqrt(252)):.2f}", int(res_bt['Signal'].diff().abs().sum())]}))
        
        fig_f = go.Figure()
        fig_f.add_trace(go.Scatter(x=res_bt.index, y=res_bt['Close'], name="Forecast", line=dict(color='#94a3b8')))
        buys = res_bt[res_bt['Signal'].diff() == 1]; sells = res_bt[res_bt['Signal'].diff() == -1]
        fig_f.add_trace(go.Scatter(x=buys.index, y=buys['Close'], mode='markers', name='BUY', marker=dict(symbol='triangle-up', size=15, color='green')))
        fig_f.add_trace(go.Scatter(x=sells.index, y=sells['Close'], mode='markers', name='SELL', marker=dict(symbol='triangle-down', size=15, color='red')))
        st.plotly_chart(fig_f, use_container_width=True)
        

    # --- TAB 4: CREDIT RISK ---
    with tab4:
        st.title("Probability of Default (Merton/KMV)")
        @st.cache_data(ttl=3600)
        def fetch_debt(ticker):
            t = yf.Ticker(ticker); bs = t.balance_sheet; info = t.info
            def get_v(lbs):
                for l in lbs:
                    matches = [i for i in bs.index if l.lower() in str(i).lower()]
                    if matches: return bs.loc[matches[0]].iloc[0] / 1e7
                return 0.0
            std = get_v(['Current Debt', 'Short Term Borrowings']); ltd = get_v(['Long Term Debt', 'Long Term Borrowings'])
            return std, ltd, info.get('totalDebt', 0)/1e7, info.get('marketCap', 1)/1e7

        std, ltd, total_d, mcap = fetch_debt(sel_stock)
        st.table(pd.DataFrame({"Component": ["ST Debt", "LT Debt", "Total Debt", "Market Cap"], "Value (Cr ‚Çπ)": [f"{std:,.2f}", f"{ltd:,.2f}", f"{total_d:,.2f}", f"{mcap:,.2f}"]}))
        
        m_type = st.radio("Model", ["Merton", "KMV"])
        barrier = (std + 0.5 * ltd) if m_type == "KMV" else total_d
        barrier = st.number_input("Default Barrier (Cr ‚Çπ)", value=float(barrier) if barrier > 0 else 5000.0)
        
        def solve_m(E, se, L, r, T):
            def eq(p):
                V, sv = p; d1 = (np.log(V/L) + (r + 0.5 * sv**2) * T) / (sv * np.sqrt(T)); d2 = d1 - sv * np.sqrt(T)
                return [V * norm.cdf(d1) - L * np.exp(-r * T) * norm.cdf(d2) - E, (norm.cdf(d1) * V / E) * sv - se]
            return fsolve(eq, [E + L, se * (E / (E + L))])

        try:
            va, sa = solve_m(mcap, ann_risk, barrier, rf_rate, 1.0)
            dd = (np.log(va/barrier) + (rf_rate - 0.5 * sa**2)) / sa; pd_v = norm.cdf(-dd)
            c1, c2, c3, c4 = st.columns(4)
            c1.metric("Distance to Default", f"{dd:.2f} œÉ"); c2.metric("Prob. of Default", f"{pd_v:.4%}")
            c3.metric("Asset Value (Cr)", f"‚Çπ{va:,.0f}"); c4.metric("Asset Volatility", f"{sa:.2%}")
        except: st.error("Solver Error: Debt/Equity ratio likely extreme.")
        

else: st.error("Data error. Check ticker or internet.")


