# -*- coding: utf-8 -*-
"""QuantEdge Intelligence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gkmpljoOIvjbKUjTAM0G8OCGRZI-inXT
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
from scipy.stats import norm, probplot
from arch import arch_model
import statsmodels.api as sm

# --- Page Configuration ---
st.set_page_config(page_title="Quant Stock Analysis Pro", layout="wide", page_icon="üìà")

# --- Helper Functions ---
@st.cache_data
def get_stock_data(ticker, start_date, end_date):
    try:
        data = yf.download(ticker, start=start_date, end=end_date)
        if isinstance(data.columns, pd.MultiIndex):
            data.columns = data.columns.get_level_values(0)
        return data
    except Exception as e:
        st.error(f"Error fetching data: {e}")
        return pd.DataFrame()

def calculate_rsi(data, window=14):
    delta = data.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

def calculate_metrics(df):
    if df.empty: return {}
    last_price = df['Close'].iloc[-1]
    prev_price = df['Close'].iloc[-2]
    daily_ret = df['Close'].pct_change().dropna()
    
    days = (df.index[-1] - df.index[0]).days
    cagr = ((df['Close'].iloc[-1] / df['Close'].iloc[0]) ** (365/days)) - 1
    volatility = daily_ret.std() * np.sqrt(252)
    sharpe = (daily_ret.mean() / daily_ret.std()) * np.sqrt(252)
    
    cumulative = (1 + daily_ret).cumprod()
    peak = cumulative.cummax()
    drawdown = (cumulative - peak) / peak
    max_drawdown = drawdown.min()
    
    return {
        "Current Price": last_price,
        "Daily Change %": (last_price - prev_price) / prev_price * 100,
        "CAGR %": cagr * 100,
        "Volatility %": volatility * 100,
        "Sharpe Ratio": sharpe,
        "Max Drawdown %": max_drawdown * 100
    }

# --- Sidebar ---
st.sidebar.header("Configuration")
ticker = st.sidebar.text_input("Enter Stock Ticker", "RELIANCE.NS")
benchmark_ticker = st.sidebar.text_input("Benchmark Ticker", "^NSEI")
start_date = st.sidebar.date_input("Start Date", datetime.now() - timedelta(days=365*2))
end_date = st.sidebar.date_input("End Date", datetime.now())

if st.sidebar.button("Force Refresh"):
    st.cache_data.clear()
    st.rerun()

st.sidebar.markdown("---")
# [Application Brief & Capabilities]
st.sidebar.subheader("‚ÑπÔ∏è Application Brief")
st.sidebar.info("""
This application delivers a complete single-stock analytics engine combining valuation models, risk metrics, trend signals, volatility forecasting, and credit analysis. 

It gives traders and investors a clear, data-driven view of a stock‚Äôs attractiveness, risk profile, and relative position against peers.
""")

st.sidebar.subheader("Key Capabilities")
st.sidebar.markdown("""
* **Valuation Models:** CAPM & Alpha Analysis.
* **19 Quant Ratios:** Performance & Risk metrics.
* **Trend Analysis:** 200-MA, RSI, Bollinger Bands.
* **Strategy:** GARCH(1,1) Volatility Forecasting & NIC.
* **Credit Risk:** Merton Distance-to-Default Model.
* **Market Risk:** VaR, CVaR, Stress Testing.
* **Comparison:** Automated "Best Stock" Ranking.
""")

st.sidebar.markdown("---")
st.sidebar.markdown("### Developer Profile")
st.sidebar.success("Built for Insignia NMIMS by a Financial Analyst & Data Enthusiast.")

# --- Main Logic ---
df = get_stock_data(ticker, start_date, end_date)
bench_df = get_stock_data(benchmark_ticker, start_date, end_date)

if not df.empty:
    st.title(f"üìà Quantitative Analysis: {ticker}")
    
    # Top Level Metrics
    metrics = calculate_metrics(df)
    c1, c2, c3, c4 = st.columns(4)
    c1.metric("Current Price", f"‚Çπ{metrics['Current Price']:.2f}", f"{metrics['Daily Change %']:.2f}%")
    c2.metric("CAGR", f"{metrics['CAGR %']:.2f}%")
    c3.metric("Volatility", f"{metrics['Volatility %']:.2f}%")
    c4.metric("Sharpe Ratio", f"{metrics['Sharpe Ratio']:.2f}")

    # Tabs Structure
    tabs = st.tabs(["üìä Analysis", "üí∞ Valuation", "üß† Strategy (GARCH)", "‚ö†Ô∏è Market Risk", "üõ°Ô∏è Credit Risk", "‚öñÔ∏è Comparison"])

    # --- TAB 1: Analysis (Technical & Fundamental) ---
    with tabs[0]:
        st.subheader("Technical Analysis")
        
        # Technical Indicators
        df['SMA_50'] = df['Close'].rolling(window=50).mean()
        df['SMA_200'] = df['Close'].rolling(window=200).mean()
        df['RSI'] = calculate_rsi(df['Close'])
        df['BB_Mid'] = df['Close'].rolling(window=20).mean()
        df['BB_Std'] = df['Close'].rolling(window=20).std()
        df['BB_Upper'] = df['BB_Mid'] + (2 * df['BB_Std'])
        df['BB_Lower'] = df['BB_Mid'] - (2 * df['BB_Std'])

        # Price Chart
        fig_candle = go.Figure()
        fig_candle.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Price'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['SMA_50'], line=dict(color='orange', width=1), name='SMA 50'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['SMA_200'], line=dict(color='blue', width=1), name='SMA 200'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['BB_Upper'], line=dict(color='gray', width=1, dash='dot'), name='BB Upper'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['BB_Lower'], line=dict(color='gray', width=1, dash='dot'), name='BB Lower'))
        fig_candle.update_layout(title=f"{ticker} Technical Chart", height=600)
        st.plotly_chart(fig_candle, use_container_width=True)
        
        c_t1, c_t2 = st.columns(2)
        with c_t1:
            fig_vol = px.bar(df, x=df.index, y='Volume', title="Trading Volume")
            st.plotly_chart(fig_vol, use_container_width=True)
        with c_t2:
            fig_rsi = go.Figure()
            fig_rsi.add_trace(go.Scatter(x=df.index, y=df['RSI'], name='RSI', line=dict(color='purple')))
            fig_rsi.add_hline(y=70, line_dash="dash", line_color="red")
            fig_rsi.add_hline(y=30, line_dash="dash", line_color="green")
            fig_rsi.update_layout(title="Relative Strength Index (RSI)", yaxis_title="RSI")
            st.plotly_chart(fig_rsi, use_container_width=True)

    # --- TAB 2: Valuation (RESTORED) ---
    with tabs[1]:
        st.subheader("Valuation Models (CAPM)")
        if not bench_df.empty:
            # Data Alignment
            asset_ret = df['Close'].pct_change().dropna()
            bench_ret = bench_df['Close'].pct_change().dropna()
            common = asset_ret.index.intersection(bench_ret.index)
            
            y = asset_ret.loc[common]
            X = bench_ret.loc[common]
            X = sm.add_constant(X)
            
            model = sm.OLS(y, X).fit()
            alpha, beta = model.params.iloc[0], model.params.iloc[1]
            
            col_v1, col_v2 = st.columns(2)
            with col_v1:
                st.markdown(f"### Beta: {beta:.2f}")
                st.write("Sensitivity to market movements.")
                if beta > 1: st.warning("High Beta: Stock is more volatile than the market.")
                else: st.success("Low Beta: Stock is less volatile than the market.")
                
            with col_v2:
                st.markdown(f"### Alpha (Daily): {alpha:.4f}")
                st.write("Excess return over benchmark.")
                if alpha > 0: st.success("Positive Alpha: Outperforming benchmark.")
                else: st.error("Negative Alpha: Underperforming benchmark.")
            
            # Regression Plot
            fig_capm = px.scatter(x=bench_ret.loc[common], y=asset_ret.loc[common], labels={'x': 'Market Returns', 'y': 'Asset Returns'}, title=f"CAPM Regression (R¬≤: {model.rsquared:.2f})", opacity=0.5)
            fig_capm.add_trace(go.Scatter(x=bench_ret.loc[common], y=model.predict(X), mode='lines', name='Regression Line', line=dict(color='red')))
            st.plotly_chart(fig_capm, use_container_width=True)
        else:
            st.warning("Benchmark data missing. Cannot calculate CAPM.")

    # --- TAB 3: Strategy (GARCH) (NEW FEATURES) ---
    with tabs[2]:
        st.subheader("GARCH(1,1) Volatility Strategy")
        returns = df['Close'].pct_change().dropna() * 100 
        
        am = arch_model(returns, vol='Garch', p=1, o=0, q=1, dist='Normal')
        res = am.fit(disp='off')
        
        st.write(res.summary())

        # GARCH Plots
        col_g1, col_g2 = st.columns(2)
        with col_g1:
            # 1. Conditional Volatility
            fig_vol = go.Figure()
            fig_vol.add_trace(go.Scatter(x=res.conditional_volatility.index, y=res.conditional_volatility, 
                                         mode='lines', name='Cond. Volatility', line=dict(color='orange')))
            fig_vol.update_layout(title="Conditional Volatility (Time Series)", xaxis_title="Date", yaxis_title="Volatility")
            st.plotly_chart(fig_vol, use_container_width=True)

        with col_g2:
            # 2. Forecast
            forecasts = res.forecast(horizon=5)
            vol_forecast = np.sqrt(forecasts.variance.iloc[-1])
            fig_for = go.Figure()
            fig_for.add_trace(go.Bar(x=[f"Day {i+1}" for i in range(5)], y=vol_forecast, marker_color='purple'))
            fig_for.update_layout(title="5-Day Volatility Forecast", yaxis_title="Predicted Volatility")
            st.plotly_chart(fig_for, use_container_width=True)

        # 3. NIC
        st.markdown("#### News Impact Curve (NIC)")
        params = res.params
        uncond_var = res.conditional_volatility.var() 
        epsilon_range = np.linspace(returns.min(), returns.max(), 100)
        nic_sigma2 = params['omega'] + params['alpha[1]'] * (epsilon_range**2) + params['beta[1]'] * uncond_var
        
        fig_nic = go.Figure()
        fig_nic.add_trace(go.Scatter(x=epsilon_range, y=nic_sigma2, mode='lines', line=dict(color='firebrick')))
        fig_nic.update_layout(title="News Impact Curve", xaxis_title="Shock (Œµ)", yaxis_title="Conditional Variance (œÉ¬≤)")
        st.plotly_chart(fig_nic, use_container_width=True)

    # --- TAB 4: Market Risk (NEW TAB) ---
    with tabs[3]:
        st.subheader("‚ö†Ô∏è Market Risk Analysis")
        returns_dec = df['Close'].pct_change().dropna()
        
        confidence_level = 0.95
        var_95 = np.percentile(returns_dec, (1-confidence_level)*100)
        cvar_95 = returns_dec[returns_dec <= var_95].mean()
        
        st.markdown(f"**95% VaR:** {var_95:.4f} ({var_95*100:.2f}%) | **95% CVaR:** {cvar_95:.4f} ({cvar_95*100:.2f}%)")

        col_r1, col_r2 = st.columns(2)
        with col_r1:
            # Historical VaR
            window = 30
            rolling_var = returns_dec.rolling(window).quantile(1-confidence_level)
            fig_rvar = go.Figure()
            fig_rvar.add_trace(go.Scatter(x=rolling_var.index, y=rolling_var, fill='tozeroy', line=dict(color='firebrick'), name='95% VaR'))
            fig_rvar.add_trace(go.Scatter(x=returns_dec.index, y=returns_dec, mode='lines', line=dict(color='grey', width=0.5, opacity=0.5), name='Returns'))
            fig_rvar.update_layout(title=f"Historical Rolling {window}-Day VaR", yaxis_title="Return")
            st.plotly_chart(fig_rvar, use_container_width=True)

        with col_r2:
             # CVaR Plot
            fig_hist = px.histogram(returns_dec, nbins=50, title="Return Distribution & CVaR Region")
            fig_hist.add_vline(x=var_95, line_dash="dash", line_color="red", annotation_text="VaR 95%")
            fig_hist.add_vrect(x0=returns_dec.min(), x1=var_95, fillcolor="red", opacity=0.2, annotation_text="CVaR Area")
            st.plotly_chart(fig_hist, use_container_width=True)

        col_r3, col_r4 = st.columns(2)
        with col_r3:
            # Rolling Beta
            if not bench_df.empty:
                bench_ret = bench_df['Close'].pct_change().dropna()
                common_idx = returns_dec.index.intersection(bench_ret.index)
                roll_cov = returns_dec.loc[common_idx].rolling(60).cov(bench_ret.loc[common_idx])
                roll_var = bench_ret.loc[common_idx].rolling(60).var()
                rolling_beta = roll_cov / roll_var
                
                fig_beta = go.Figure()
                fig_beta.add_trace(go.Scatter(x=rolling_beta.index, y=rolling_beta, mode='lines', name='60-Day Beta'))
                fig_beta.add_hline(y=1, line_dash="dot", line_color="black")
                fig_beta.update_layout(title="Rolling Beta (vs Benchmark)", yaxis_title="Beta")
                st.plotly_chart(fig_beta, use_container_width=True)

        with col_r4:
            # QQ Plot
            qq_data = probplot(returns_dec, dist="norm")
            fig_qq = px.scatter(x=qq_data[0][0], y=qq_data[0][1], labels={'x': 'Theoretical', 'y': 'Sample'}, title="QQ Plot of Returns")
            slope, intercept, r = qq_data[1]
            line_x = np.array([min(qq_data[0][0]), max(qq_data[0][0])])
            line_y = slope * line_x + intercept
            fig_qq.add_trace(go.Scatter(x=line_x, y=line_y, mode='lines', name='Normal Fit', line=dict(color='red')))
            st.plotly_chart(fig_qq, use_container_width=True)

        # Stress Testing
        st.markdown("#### üí• Stress Testing")
        current_capital = st.number_input("Portfolio Value (‚Çπ)", value=100000)
        scenarios = {"Mild (-10%)": -0.10, "Bear (-20%)": -0.20, "Crash (-30%)": -0.30, "Crisis (-50%)": -0.50}
        loss_data = [{"Scenario": k, "Projected Value": current_capital * (1+v), "Loss": current_capital * v} for k, v in scenarios.items()]
        fig_stress = px.bar(pd.DataFrame(loss_data), x="Scenario", y="Loss", text="Loss", title="Hypothetical P&L", color="Loss", color_continuous_scale="Reds_r")
        st.plotly_chart(fig_stress, use_container_width=True)

    # --- TAB 5: Credit Risk (RESTORED) ---
    with tabs[4]:
        st.subheader("üõ°Ô∏è Credit Risk (Merton Model)")
        st.info("Estimates 'Distance to Default' based on equity volatility and debt levels.")
        
        # User Inputs for Merton
        col_c1, col_c2, col_c3 = st.columns(3)
        total_debt = col_c1.number_input("Total Debt (‚Çπ Crores)", value=100000.0)
        risk_free = col_c2.number_input("Risk Free Rate (%)", value=7.0) / 100
        time_horizon = col_c3.number_input("Time Horizon (Years)", value=1.0)
        
        # Calculations
        market_cap = metrics["Current Price"] * 1000000 # Placeholder for actual shares outstanding
        equity_vol = metrics["Volatility %"] / 100
        
        # Simple Distance to Default (DD) Approximation
        # DD = (ln(Asset_Value / Debt) + (r - 0.5*sigma^2)*T) / (sigma * sqrt(T))
        # Here we approximate Asset Value ~ Market Cap + Debt
        asset_value = market_cap + total_debt
        asset_vol = equity_vol * (market_cap / asset_value) # Levered vol approx
        
        d1 = (np.log(asset_value / total_debt) + (risk_free + 0.5 * asset_vol ** 2) * time_horizon) / (asset_vol * np.sqrt(time_horizon))
        dd = d1 # Distance to default in standard deviations
        prob_default = norm.cdf(-dd)
        
        col_res1, col_res2 = st.columns(2)
        col_res1.metric("Distance to Default (DD)", f"{dd:.2f} œÉ")
        col_res2.metric("Implied Probability of Default", f"{prob_default:.4%}")
        
        if dd < 1.5:
            st.error("High Credit Risk: Distance to Default is low.")
        elif dd < 3:
            st.warning("Moderate Credit Risk.")
        else:
            st.success("Low Credit Risk: Healthy Distance to Default.")

    # --- TAB 6: Comparison (UPDATED) ---
    with tabs[5]:
        st.subheader("Compare Stocks")
        tickers_input = st.text_input("Enter Tickers (comma separated)", "RELIANCE.NS, TCS.NS, INFY.NS, HDFCBANK.NS")
        comp_tickers = [t.strip() for t in tickers_input.split(',')]
        
        if st.button("Compare"):
            comp_data = []
            for t in comp_tickers:
                d = get_stock_data(t, start_date, end_date)
                if not d.empty:
                    m = calculate_metrics(d)
                    m['Ticker'] = t
                    comp_data.append(m)
            
            if comp_data:
                df_comp = pd.DataFrame(comp_data).set_index('Ticker')
                
                # Winner Logic
                best_row = {}
                for col in df_comp.columns:
                    if col in ["Volatility %", "Max Drawdown %"]:
                        best_val = df_comp[col].min() if col == "Volatility %" else df_comp[col].max()
                        best_ticker = df_comp[col].idxmin() if col == "Volatility %" else df_comp[col].idxmax()
                    else:
                        best_val = df_comp[col].max()
                        best_ticker = df_comp[col].idxmax()
                    best_row[col] = f"{best_ticker} ({best_val:.2f})"

                df_comp_display = df_comp.copy()
                df_comp_display.loc['üèÜ WINNER'] = pd.Series(best_row)

                st.table(df_comp_display)
                
                # Comparison Chart
                st.subheader("Relative Performance")
                norm_data = pd.DataFrame()
                for t in comp_tickers:
                    d = get_stock_data(t, start_date, end_date)
                    if not d.empty:
                        norm_data[t] = (d['Close'] / d['Close'].iloc[0]) * 100
                st.line_chart(norm_data)
else:
    st.info("Enter a ticker in the sidebar to begin.")


