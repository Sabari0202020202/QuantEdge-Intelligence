# -*- coding: utf-8 -*-
"""QuantEdge Intelligence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gkmpljoOIvjbKUjTAM0G8OCGRZI-inXT
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from arch import arch_model
from datetime import datetime, timedelta
from scipy.stats import norm, skew, kurtosis
from scipy.optimize import fsolve

# --- LIGHT THEME UI & STYLING ---
st.set_page_config(page_title="Sabarimayur's 360¬∞ Stock Strategy & Valuation Suite", layout="wide")
st.markdown("""
    <style>
    .stApp { background-color: #f8fafc; color: #1e293b; }
    [data-testid="stMetricValue"] { color: #1e3a8a !important; font-weight: 800; }
    [data-testid="metric-container"] { 
        background-color: #ffffff; border: 1px solid #e2e8f0; 
        border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .valuation-card { 
        padding: 20px; border-radius: 12px; background-color: #ffffff; 
        border: 1px solid #e2e8f0; border-top: 4px solid #2563eb; 
        margin-bottom: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.07);
    }
    .status-undervalued { color: #16a34a; font-weight: bold; }
    .status-overvalued { color: #dc2626; font-weight: bold; }
    .linkedin-box {
        background-color: #0077b5; color: white !important;
        padding: 12px; border-radius: 8px; text-align: center;
        text-decoration: none; display: block; font-weight: bold; margin-top: 15px;
    }
    .nav-btn {
        width: 100%; border-radius: 5px; border: 1px solid #cbd5e1; background-color: #f1f5f9;
    }
    </style>
    """, unsafe_allow_html=True)

# --- NAVIGATION STATE MANAGEMENT ---
TAB_NAMES = ["üîç Selection", "üíé Analysis & Valuation", "üèóÔ∏è Structure", "üîÆ Strategy", "üìâ Credit Risk", "‚öñÔ∏è Multi-Stock Compare"]

if 'active_tab' not in st.session_state:
    st.session_state.active_tab = TAB_NAMES[0]

def switch_tab(tab_name):
    st.session_state.active_tab = tab_name

# --- SIDEBAR ---
with st.sidebar:
    st.title("üõ°Ô∏è 360¬∞ Stock Strategy & Valuation Suite")
    
    if st.button("üè† Go to Selection", use_container_width=True):
        switch_tab(TAB_NAMES[0])
    
    if st.button("üîÑ Force Refresh", use_container_width=True):
        st.cache_data.clear()
        st.success("Cache Cleared.")

    st.markdown("---")
    st.markdown("### **Developer Profile**")
    st.markdown("**Name:** *Sabarimayurnath U*")
    st.caption("Pursuing MBA Finance from NMIMS, Bengaluru")
    st.markdown("**Email:** `u.sabarimayurnath@gmail.com`")
    st.markdown(f'<a href="https://www.linkedin.com/in/sabarimayurnath-u/" target="_blank" class="linkedin-box">Connect on LinkedIn</a>', unsafe_allow_html=True)
    st.markdown("---")
    st.caption("¬© 2026 QuantPro Intelligence")

# --- MAIN NAVIGATION HEADER ---
# We use a radio button styled horizontally to act as the Tab Controller
selected_tab = st.radio("", TAB_NAMES, index=TAB_NAMES.index(st.session_state.active_tab), horizontal=True, label_visibility="collapsed")
if selected_tab != st.session_state.active_tab:
    st.session_state.active_tab = selected_tab
    st.rerun()

# --- DATA ENGINE ---
@st.cache_data(ttl=3600)
def fetch_stock_data(ticker, yrs):
    start = datetime.now() - timedelta(days=yrs*365 + 365) 
    try:
        df = yf.download([ticker, "^NSEI", "^NSEBANK"], start=start.strftime('%Y-%m-%d'), progress=False)['Close']
        if isinstance(df.columns, pd.MultiIndex): df.columns = df.columns.get_level_values(1)
        df = df.dropna(subset=[ticker]).ffill()
        
        t = yf.Ticker(ticker); info = t.info; bs = t.balance_sheet
        
        def get_d(labels):
            for l in labels:
                match = [i for i in bs.index if l.lower() in str(i).lower()]
                if match: return bs.loc[match[0]].iloc[0] / 1e7
            return 0.0
            
        return {
            "df": df, "ltp": df[ticker].iloc[-1], 
            "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "mcap": info.get('marketCap', 0)/1e7, "total_d": info.get('totalDebt', 0)/1e7,
            "st_d": get_d(['Current Debt', 'Short Term']), "lt_d": get_d(['Long Term'])
        }
    except: return None

# --- TAB 0: SELECTION ---
if st.session_state.active_tab == "üîç Selection":
    st.title("Asset Selection Gateway")
    c1, c2, c3 = st.columns(3)
    with c1:
        sel_mode = st.selectbox("Select Asset", ["RELIANCE.NS", "TCS.NS", "HDFCBANK.NS", "INFY.NS", "SBIN.NS", "TATAMOTORS.NS", "Others"])
        if sel_mode == "Others":
            st.session_state.sel_stock = st.text_input("Enter Yahoo Ticker", "ZOMATO.NS").upper()
        else: st.session_state.sel_stock = sel_mode
    with c2:
        st.session_state.lookback = st.slider("Timeframe (Years)", 1, 15, 5)
    with c3:
        st.session_state.rf_rate = st.number_input("Risk Free Rate %", value=7.1) / 100
        
    st.success(f"Active Asset: **{st.session_state.sel_stock}** | Risk-Free Rate: **{st.session_state.rf_rate:.1%}**")
    
    st.markdown("---")
    if st.button("Next: Analysis & Valuation ‚û°", use_container_width=True): switch_tab(TAB_NAMES[1]); st.rerun()

# --- LOAD DATA FOR TABS 1-5 ---
elif st.session_state.active_tab in TAB_NAMES[1:5]:
    if 'sel_stock' not in st.session_state: st.session_state.sel_stock = "RELIANCE.NS"; st.session_state.lookback = 5; st.session_state.rf_rate = 0.071
    
    res = fetch_stock_data(st.session_state.sel_stock, st.session_state.lookback)
    
    if res:
        data = res['df']; returns = data[st.session_state.sel_stock].pct_change().dropna()
        mkt_rets = data["^NSEI"].pct_change().dropna()
        ann_ret = returns.mean() * 252; ann_vol = returns.std() * np.sqrt(252)
        cagr = (data[st.session_state.sel_stock].iloc[-1] / data[st.session_state.sel_stock].iloc[0])**(1/st.session_state.lookback) - 1
        
        # --- TAB 1: VALUATION ---
        if st.session_state.active_tab == "üíé Analysis & Valuation":
            st.title(f"Analysis & Valuation: {st.session_state.sel_stock}")
            st.write(f"**LTP:** ‚Çπ{res['ltp']:,.2f} | **Updated:** {res['time']}")
            
            beta = (returns.cov(mkt_rets) * 252) / (mkt_rets.var() * 252)
            capm = st.session_state.rf_rate + beta * (mkt_rets.mean()*252 - st.session_state.rf_rate)
            ff = st.session_state.rf_rate + (beta * 0.08) + (returns.rolling(252).corr(data['^NSEBANK'].pct_change()).iloc[-1] * 0.02)
            apt = capm + 0.015
            
            st.subheader("Multi-Factor Alphas")
            v1, v2, v3 = st.columns(3)
            def draw_v(c, n, e, a, h):
                al = a - e; vc = "status-undervalued" if al > 0 else "status-overvalued"
                c.markdown(f"<div class='valuation-card' title='{h}'><small>{n}</small><h3>Exp: {e:.2%}</h3><p class='{vc}'>Alpha: {al:+.2%} ({( 'Under' if al>0 else 'Over' )}valued)</p></div>", unsafe_allow_html=True)
            draw_v(v1, "CAPM", capm, cagr, "Beta-adjusted market baseline"); draw_v(v2, "4-Factor", ff, cagr, "Size/Momentum proxy"); draw_v(v3, "APT", apt, cagr, "Macro-proxy")

            st.divider()
            st.subheader("19-Point Risk Suite")
            sharpe = (ann_ret - st.session_state.rf_rate)/ann_vol
            dd = (data[st.session_state.sel_stock] - data[st.session_state.sel_stock].cummax()) / data[st.session_state.sel_stock].cummax()
            
            r1, r2, r3, r4 = st.columns(4)
            r1.metric("CAGR", f"{cagr:.2%}", help="Compound Annual Growth Rate"); r2.metric("Sharpe", f"{sharpe:.2f}", help="Return/Risk"); r3.metric("Max DD", f"{dd.min():.2%}", help="Max Drawdown"); r4.metric("Ann. Vol", f"{ann_vol:.2%}", help="Annual Volatility")
            
            r5, r6, r7, r8 = st.columns(4)
            r5.metric("Sortino", f"{(ann_ret - st.session_state.rf_rate)/(returns[returns<0].std()*np.sqrt(252)):.2f}", help="Downside Risk Ratio"); r6.metric("Calmar", f"{ann_ret/abs(dd.min()):.2f}", help="Return vs Max DD"); r7.metric("Ulcer Index", f"{np.sqrt(np.mean(dd**2)):.2f}"); r8.metric("VaR 95%", f"{np.percentile(returns, 5):.2%}")

            r9, r10, r11, r12 = st.columns(4)
            r9.metric("CVaR 95%", f"{returns[returns<=np.percentile(returns, 5)].mean():.2%}"); r10.metric("Skew", f"{skew(returns):.2f}"); r11.metric("Kurtosis", f"{kurtosis(returns):.2f}"); r12.metric("Profit Factor", f"{abs(returns[returns>0].sum()/returns[returns<0].sum()):.2f}")
            
            r13, r14, r15 = st.columns(3)
            r13.metric("Win Rate", f"{len(returns[returns>0])/len(returns):.2%}"); r14.metric("Beta", f"{beta:.2f}"); r15.metric("Alpha (CAPM)", f"{cagr-capm:.2%}")
            
            st.markdown("---")
            n1, n2 = st.columns(2)
            if n1.button("‚¨Ö Back to Selection", key="n1"): switch_tab(TAB_NAMES[0]); st.rerun()
            if n2.button("Next: Structure ‚û°", key="n2"): switch_tab(TAB_NAMES[2]); st.rerun()

        # --- TAB 2: STRUCTURE ---
        elif st.session_state.active_tab == "üèóÔ∏è Structure":
            st.title("Structural DNA")
            data['MA50'], data['MA200'] = data[st.session_state.sel_stock].rolling(50).mean(), data[st.session_state.sel_stock].rolling(200).mean()
            
            c1, c2, c3 = st.columns(3)
            with c1: st.metric("Trend vs 200-MA", "‚úÖ BULLISH" if res['ltp'] > data['MA200'].iloc[-1] else "‚ùå BEARISH")
            with c2: st.metric("50/200 MA Cross", "üî• GOLDEN" if data['MA50'].iloc[-1] > data['MA200'].iloc[-1] else "‚ùÑÔ∏è DEATH")
            with c3: st.metric("Dist. 52W High", f"{((res['ltp']/data[st.session_state.sel_stock].max())-1):.2%}")
            
            st.subheader("Price Memory Chart")
            res_p, supp = data[st.session_state.sel_stock].tail(22).max(), data[st.session_state.sel_stock].tail(22).min()
            fig = go.Figure()
            fig.add_trace(go.Scatter(x=data.index, y=data[st.session_state.sel_stock], name="Price"))
            fig.add_hline(y=res_p, line_color="green", line_dash="dash", annotation_text="Resis")
            fig.add_hline(y=supp, line_color="red", line_dash="dash", annotation_text="Supp")
            st.plotly_chart(fig, use_container_width=True)
            

            st.markdown("---")
            n3, n4 = st.columns(2)
            if n3.button("‚¨Ö Back to Valuation", key="n3"): switch_tab(TAB_NAMES[1]); st.rerun()
            if n4.button("Next: Strategy ‚û°", key="n4"): switch_tab(TAB_NAMES[3]); st.rerun()

        # --- TAB 3: STRATEGY ---
        elif st.session_state.active_tab == "üîÆ Strategy":
            st.title("GARCH Volatility & Strategy Forecast")
            ret_g = 100 * returns; am = arch_model(ret_g, vol='Garch', p=1, q=1, dist='t'); res_g = am.fit(disp="off")
            
            c1, c2 = st.columns(2)
            c1.metric("Shock Volatility", f"{res_g.conditional_volatility.iloc[-1]:.2f}")
            c2.metric("Persistence (Beta)", f"{res_g.params['beta[1]']:.3f}")
            with st.expander("GARCH Summary"): st.text(res_g.summary())
            
            st.divider()
            strat = st.selectbox("Methodology", ["Triple Golden Cross", "RSI", "SMA Crossover"])
            
            # Forecast Logic
            f_vol = np.sqrt(res_g.forecast(horizon=252).variance.values[-1, :]) / 100
            p_f = [res['ltp']]; np.random.seed(42)
            for i in range(252): p_f.append(p_f[-1] * np.exp(returns.mean() + f_vol[i] * np.random.standard_normal()))
            df_f = pd.DataFrame({'Close': p_f[1:]}, index=[data.index[-1] + timedelta(days=i) for i in range(1, 253)])
            
            if strat == "Triple Golden Cross":
                t1, t2, t3 = st.columns(3)
                s_p = t1.number_input("Short MA", 10); m_p = t2.number_input("Mid MA", 50); l_p = t3.number_input("Long MA", 200)
                df_f['S'], df_f['M'], df_f['L'] = df_f['Close'].rolling(s_p).mean(), df_f['Close'].rolling(m_p).mean(), df_f['Close'].rolling(l_p).mean()
                df_f['Signal'] = np.where((df_f['S'] > df_f['M']) & (df_f['S'] < df_f['L']), 1, 0)
            elif strat == "RSI":
                rp = st.slider("RSI Period", 7, 30, 14)
                d = df_f['Close'].diff(); g = d.where(d>0, 0).rolling(rp).mean(); l = -d.where(d<0, 0).rolling(rp).mean()
                df_f['Signal'] = np.where((100 - (100/(1+(g/l)))) < 30, 1, 0)
            else:
                p1, p2 = st.columns(2)
                fast = p1.number_input("Fast SMA", value=20); slow = p2.number_input("Slow SMA", value=50)
                df_f['Signal'] = np.where(df_f['Close'].rolling(fast).mean() > df_f['Close'].rolling(slow).mean(), 1, 0)

            s_ret = df_f['Signal'].shift(1) * df_f['Close'].pct_change()
            st.table(pd.DataFrame({"Metric": ["Return", "Risk", "Sharpe", "Trades"], "Forecast": [f"{s_ret.mean()*252:.2%}", f"{s_ret.std()*np.sqrt(252):.2%}", f"{(s_ret.mean()*252)/(s_ret.std()*np.sqrt(252)) if s_ret.std()!=0 else 0:.2f}", int(df_f['Signal'].diff().abs().sum())]}))
            
            fig = go.Figure()
            fig.add_trace(go.Scatter(x=df_f.index, y=df_f['Close'], name="Forecast"))
            buys = df_f[df_f['Signal'].diff() == 1]; sells = df_f[df_f['Signal'].diff() == -1]
            fig.add_trace(go.Scatter(x=buys.index, y=buys['Close'], mode='markers', marker=dict(color='green', symbol='triangle-up', size=15), name="Buy"))
            fig.add_trace(go.Scatter(x=sells.index, y=sells['Close'], mode='markers', marker=dict(color='red', symbol='triangle-down', size=15), name="Sell"))
            st.plotly_chart(fig, use_container_width=True)

            st.markdown("---")
            n5, n6 = st.columns(2)
            if n5.button("‚¨Ö Back to Structure", key="n5"): switch_tab(TAB_NAMES[2]); st.rerun()
            if n6.button("Next: Credit Risk ‚û°", key="n6"): switch_tab(TAB_NAMES[4]); st.rerun()

        # --- TAB 4: CREDIT RISK ---
        elif st.session_state.active_tab == "üìâ Credit Risk":
            st.title("Structural Credit Risk (Merton/KMV)")
            st.table(pd.DataFrame({"Metric": ["ST Debt", "LT Debt", "Total Debt", "Market Cap"], "Value (Cr ‚Çπ)": [f"{res['st_d']:,.2f}", f"{res['lt_d']:,.2f}", f"{res['total_d']:,.2f}", f"{res['mcap']:,.2f}"]}))
            
            mf = st.radio("Model", ["Merton", "KMV"])
            b = (res['st_d'] + 0.5 * res['lt_d']) if mf == "KMV" else res['total_d']
            barr = st.number_input("Barrier (Cr ‚Çπ)", value=float(b) if b > 0 else 5000.0)
            
            def solve(p):
                V, sv = p; d1 = (np.log(V/barr) + (st.session_state.rf_rate + 0.5*sv**2))/(sv); d2 = d1 - sv
                return [V * norm.cdf(d1) - barr * np.exp(-st.session_state.rf_rate) * norm.cdf(d2) - res['mcap'], (norm.cdf(d1)*V/res['mcap'])*sv - ann_vol]
            
            try:
                va, sa = fsolve(solve, [res['mcap'] + barr, ann_vol])
                dd_v = (np.log(va/barr) + (st.session_state.rf_rate - 0.5 * sa**2)) / sa; pd_v = norm.cdf(-dd_v)
                
                c1, c2, c3, c4 = st.columns(4)
                c1.metric("Distance to Default", f"{dd_v:.2f} œÉ"); c2.metric("Prob. of Default", f"{pd_v:.4%}")
                c3.metric("Implied Asset Value", f"‚Çπ{va:,.0f} Cr"); c4.metric("Asset Volatility", f"{sa:.2%}")
                

            except: st.error("Solver Failure.")
            
            st.markdown("---")
            n7, n8 = st.columns(2)
            if n7.button("‚¨Ö Back to Strategy", key="n7"): switch_tab(TAB_NAMES[3]); st.rerun()
            if n8.button("Next: Multi-Stock Compare ‚û°", key="n8"): switch_tab(TAB_NAMES[5]); st.rerun()

    else: st.error("Data Error. Check Ticker.")

# --- TAB 6: MULTI-STOCK COMPARE ---
elif st.session_state.active_tab == "‚öñÔ∏è Multi-Stock Compare":
    st.title("Comparative Analysis Engine")
    
    # Stock Input
    default_tickers = ["RELIANCE.NS", "TCS.NS", "HDFCBANK.NS", "INFY.NS"]
    tickers_input = st.text_area("Enter Stock Tickers (comma separated)", value=", ".join(default_tickers))
    tickers = [t.strip().upper() for t in tickers_input.split(",") if t.strip()]
    
    if st.button("Run Comparison"):
        start = datetime.now() - timedelta(days=st.session_state.lookback*365 + 365)
        try:
            df_m = yf.download(tickers + ["^NSEI"], start=start.strftime('%Y-%m-%d'), progress=False)['Close']
            if isinstance(df_m.columns, pd.MultiIndex): df_m.columns = df_m.columns.get_level_values(1)
            
            # 1. Cumulative Returns Graph
            st.subheader("Cumulative Returns Comparison")
            fig_c = go.Figure()
            metrics_list = []
            
            for t in tickers:
                if t in df_m.columns:
                    # Graph Trace
                    ret_series = df_m[t].pct_change().dropna()
                    cum_ret = (1 + ret_series).cumprod()
                    fig_c.add_trace(go.Scatter(x=cum_ret.index, y=cum_ret, name=t))
                    
                    # Metrics Calculation
                    ann_r = ret_series.mean() * 252
                    ann_v = ret_series.std() * np.sqrt(252)
                    sharpe = (ann_r - st.session_state.rf_rate) / ann_v if ann_v != 0 else 0
                    
                    # Beta/Alpha
                    mkt_ret = df_m["^NSEI"].pct_change().dropna()
                    # Align data
                    aligned = pd.concat([ret_series, mkt_ret], axis=1).dropna()
                    cov = aligned.cov().iloc[0, 1] * 252
                    var = aligned.iloc[:, 1].var() * 252
                    beta = cov / var
                    alpha = ann_r - (st.session_state.rf_rate + beta * (mkt_ret.mean()*252 - st.session_state.rf_rate))
                    
                    capm_val = "Under-Valued" if alpha > 0 else "Over-Valued"
                    
                    metrics_list.append({
                        "Ticker": t, "Ann. Return": f"{ann_r:.2%}", "Ann. Risk": f"{ann_v:.2%}",
                        "Sharpe": f"{sharpe:.2f}", "Beta": f"{beta:.2f}", "Alpha": f"{alpha:.2%}", "Valuation": capm_val
                    })
            
            st.plotly_chart(fig_c, use_container_width=True)
            
            # 2. Metrics Table
            st.subheader("Performance Matrix")
            st.dataframe(pd.DataFrame(metrics_list).set_index("Ticker"))
            
        except Exception as e: st.error(f"Error fetching comparison data: {e}")
    
    st.markdown("---")
    if st.button("‚¨Ö Back to Credit Risk", key="n9"): switch_tab(TAB_NAMES[4]); st.rerun()


