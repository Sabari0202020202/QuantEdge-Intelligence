# -*- coding: utf-8 -*-
"""QuantEdge Intelligence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gkmpljoOIvjbKUjTAM0G8OCGRZI-inXT
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from arch import arch_model
from datetime import datetime

# --- UI THEME CONFIG ---
st.set_page_config(page_title="QuantInsight India", layout="wide")

st.markdown("""
    <style>
    .stApp { background-color: #0a0f1e; color: #ffffff; }
    [data-testid="stMetricValue"] { color: #ffffff !important; font-size: 2.2rem !important; }
    [data-testid="metric-container"] { 
        background-color: #161e31; 
        border: 1px solid #3b82f6; 
        border-radius: 12px; 
    }
    h1, h2, h3 { color: #60a5fa !important; }
    .stTable { background-color: #161e31; border-radius: 10px; }
    </style>
    """, unsafe_allow_html=True)

# --- ASSET UNIVERSE ---
INDIAN_STOCKS = {
    "RELIANCE.NS": "Reliance Industries", "TCS.NS": "TCS", "HDFCBANK.NS": "HDFC Bank",
    "INFY.NS": "Infosys", "ICICIBANK.NS": "ICICI Bank", "SBIN.NS": "SBI",
    "BHARTIARTL.NS": "Bharti Airtel", "ITC.NS": "ITC", "HINDUNILVR.NS": "HUL",
    "TATAMOTORS.NS": "Tata Motors", "BAJFINANCE.NS": "Bajaj Finance", "WIPRO.NS": "Wipro"
}

@st.cache_data
def load_data(ticker):
    # Fetching Stock + Nifty 50 for benchmarking
    df = yf.download([ticker, "^NSEI"], start="2010-01-01")
    if df.empty: return None, None
    
    # Flatten multi-index columns
    prices = df['Close'].copy()
    return prices[ticker].dropna(), prices["^NSEI"].dropna()

# --- APP LAYOUT ---
st.title("ðŸ›ï¸ Institutional Wealth Intelligence")
st.write("Professional-grade volatility forecasting and backtesting for Indian Markets.")

selected_ticker = st.selectbox("Search Stock Name", options=list(INDIAN_STOCKS.keys()), 
                               format_func=lambda x: f"{INDIAN_STOCKS[x]} ({x})")

stock_data, nifty_data = load_data(selected_ticker)

if stock_data is not None:
    # --- MODULE 1: THE RISK PROFILE (Table) ---
    st.subheader("ðŸ“… Historical Risk & Return Analysis")
    
    def calc_stats(series):
        stats = {}
        for p, d in [("1Y", 252), ("2Y", 504), ("3Y", 756), ("5Y", 1260), ("MAX", len(series))]:
            if len(series) >= d:
                window = series.tail(d)
                ret = (window.iloc[-1] / window.iloc[0]) - 1
                vol = window.pct_change().std() * np.sqrt(252)
                stats[p] = {"Return": f"{ret:.2%}", "Annual Vol": f"{vol:.2%}"}
        return pd.DataFrame(stats).T

    st.table(calc_stats(stock_data))

    # --- MODULE 2: VOLATILITY FORECAST (GARCH) ---
    st.divider()
    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.subheader("ðŸ”® GARCH (1,1) Vol Forecast")
        returns = 100 * stock_data.pct_change().dropna()
        # GARCH Model
        am = arch_model(returns, vol='Garch', p=1, q=1, dist='Normal')
        res = am.fit(disp='off')
        forecast = res.forecast(horizon=1)
        future_vol = np.sqrt(forecast.variance.values[-1, :][0]) * np.sqrt(252)
        
        st.metric("Expected Annualized Volatility", f"{future_vol:.2f}%")
        st.caption("GARCH(1,1) models volatility 'clusters'. A high value suggests an upcoming period of high risk.")

    with col2:
        st.subheader("ðŸ“ˆ Growth: Stock vs Nifty 50")
        rel_growth = (1 + stock_data.pct_change()).cumprod()
        nifty_growth = (1 + nifty_data.pct_change()).cumprod()
        
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=rel_growth.index, y=rel_growth, name=selected_ticker, line=dict(color='#3b82f6')))
        fig.add_trace(go.Scatter(x=nifty_growth.index, y=nifty_growth, name="Nifty 50", line=dict(color='#94a3b8', dash='dot')))
        fig.update_layout(template="plotly_dark", paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', height=350)
        st.plotly_chart(fig, use_container_width=True)

    # --- MODULE 3: STRATEGY PLAYBOOK (Long Only) ---
    st.divider()
    st.subheader("ðŸ§ª Automated Backtesting Playbook (Long Only)")
    
    def run_strategy(series, type, p):
        df = pd.DataFrame(series)
        df.columns = ['Close']
        df['R'] = df['Close'].pct_change()
        
        if type == "SMA":
            df['S1'] = df['Close'].rolling(p[0]).mean()
            df['S2'] = df['Close'].rolling(p[1]).mean()
            df['Signal'] = np.where(df['S1'] > df['S2'], 1, 0)
        elif type == "RSI":
            change = df['Close'].diff()
            gain = (change.where(change > 0, 0)).rolling(p[0]).mean()
            loss = (-change.where(change < 0, 0)).rolling(p[0]).mean()
            rs = gain / loss
            df['RSI'] = 100 - (100 / (1 + rs))
            df['Signal'] = np.where(df['RSI'] < 30, 1, 0) # Buy Oversold

        df['Strat_R'] = df['Signal'].shift(1) * df['R']
        
        total_ret = (1 + df['Strat_R']).prod() - 1
        ann_vol = df['Strat_R'].std() * np.sqrt(252)
        sharpe = (df['Strat_R'].mean() * 252) / ann_vol if ann_vol != 0 else 0
        num_trades = (df['Signal'].diff().abs() == 1).sum()
        
        return [f"{total_ret:.2%}", f"{ann_vol:.2%}", round(sharpe, 2), int(num_trades)]

    # Multi-Combination Strategy Table
    strat_data = [
        ["SMA Fast (20/50)", "Short-Term", *run_strategy(stock_data, "SMA", [20, 50])],
        ["SMA Golden (50/200)", "Long-Term", *run_strategy(stock_data, "SMA", [50, 200])],
        ["RSI Mean Reversion", "Tactical", *run_strategy(stock_data, "RSI", [14])]
    ]
    
    strat_df = pd.DataFrame(strat_data, columns=["Strategy", "Horizon", "Exp. Return", "Risk (Vol)", "Sharpe", "Trades"])
    st.table(strat_df)

    # --- MODULE 4: POSITION SIZING ---
    st.divider()
    st.subheader("ðŸ›¡ï¸ Risk & Execution")
    capital = st.number_input("Trading Capital (â‚¹)", value=1000000)
    
    # ATR Sizing
    atr = (stock_data.rolling(14).max() - stock_data.rolling(14).min()).iloc[-1]
    risk_per_trade = capital * 0.01 # 1% Risk
    qty = int(risk_per_trade / (atr * 2)) if atr > 0 else 0
    
    c1, c2 = st.columns(2)
    c1.metric("Risk per Trade (1%)", f"â‚¹{risk_per_trade:,.0f}")
    c2.metric("Recommended Quantity", f"{qty} Units")

else:
    st.info("Select a stock from the dropdown to begin analysis.")
