# -*- coding: utf-8 -*-
"""QuantEdge Intelligence

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gkmpljoOIvjbKUjTAM0G8OCGRZI-inXT
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from arch import arch_model
from datetime import datetime, timedelta
from scipy.stats import norm, skew, kurtosis, probplot
from scipy.optimize import fsolve

# --- LIGHT THEME UI & STYLING ---
st.set_page_config(page_title="Sabarimayur's 360¬∞ Stock Strategy & Valuation Suite", layout="wide", page_icon="üõ°Ô∏è")

st.markdown("""
<style>
    .stApp { background-color: #f8fafc; color: #1e293b; }
    [data-testid="stMetricValue"] { color: #1e3a8a !important; font-weight: 800; }
    [data-testid="metric-container"] {
        background-color: #ffffff; border: 1px solid #e2e8f0;
        border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .valuation-card {
        padding: 20px; border-radius: 12px; background-color: #ffffff;
        border: 1px solid #e2e8f0; border-top: 4px solid #2563eb;
        margin-bottom: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.07);
    }
    .status-undervalued { color: #16a34a; font-weight: bold; }
    .status-overvalued { color: #dc2626; font-weight: bold; }
    .linkedin-box {
        background-color: #0077b5; color: white !important;
        padding: 12px; border-radius: 8px; text-align: center;
        text-decoration: none; display: block; font-weight: bold; margin-top: 15px;
    }
</style>
""", unsafe_allow_html=True)

# --- SIDEBAR ---
with st.sidebar:
    st.title(" üõ°Ô∏è  QuantPro Intelligence")
    st.markdown("---")
    st.markdown("### **Key Capabilities**")
    st.markdown("""
    * **Visual Analysis:** *Interactive Candlestick, BB, & Volume Charts.*
    * **Multi-Factor Valuation:** *Alpha analysis using CAPM, 4-Factor, and APT.*
    * **Volatility Engine:** *GARCH(1,1), News Impact Curve, & 5-Day Forecasts.*
    * **Strategy Backtester:** *Triple-MA and RSI Simulation.*
    * **Market Risk:** *Rolling Beta, VaR/CVaR, Stress Testing.*
    * **Credit Risk:** *Merton/KMV Probability of Default.*
    * **Comparison:** *Multi-stock Ranking & Winner Logic.*
    """)
    st.markdown("---")
    st.markdown("### **Developer Profile**")
    st.markdown("**Name:** *Sabarimayurnath U*")
    st.markdown("**Email:** `u.sabarimayurnath@gmail.com`")
    st.markdown(f'<a href="https://www.linkedin.com/in/sabarimayurnath-u/" target="_blank" class="linkedin-box">Connect on LinkedIn</a>', unsafe_allow_html=True)
    st.markdown("---")
    st.caption("¬© 2026 QuantPro Intelligence")

# --- CENTRALIZED DATA ENGINE ---
@st.cache_data(ttl=3600)
def fetch_master_data(ticker, lookback_years):
    start_date = (datetime.now() - timedelta(days=lookback_years*365 + 365)).strftime('%Y-%m-%d')
    data_pkg = {"valid": False, "error": None}

    try:
        # 1. Fetch Stock
        stock_df = yf.download(ticker, start=start_date, progress=False)
        if stock_df.empty:
            data_pkg["error"] = f"No data found for {ticker}"
            return data_pkg
        if isinstance(stock_df.columns, pd.MultiIndex):
            stock_df.columns = stock_df.columns.get_level_values(0)
        
        # 2. Fetch Benchmark (Nifty)
        nifty_df = yf.download("^NSEI", start=start_date, progress=False)
        if isinstance(nifty_df.columns, pd.MultiIndex):
            nifty_df.columns = nifty_df.columns.get_level_values(0)
            
        # 3. Fetch Sector (Bank Nifty)
        bank_df = yf.download("^NSEBANK", start=start_date, progress=False)
        if isinstance(bank_df.columns, pd.MultiIndex):
            bank_df.columns = bank_df.columns.get_level_values(0)

        # 4. Fetch Fundamentals
        t_obj = yf.Ticker(ticker)
        info = t_obj.info
        bs = t_obj.balance_sheet
        
        def get_debt_val(labels):
            for label in labels:
                match = [i for i in bs.index if label.lower() in str(i).lower()]
                if match: return bs.loc[match[0]].iloc[0] / 1e7
            return 0.0

        data_pkg["stock_df"] = stock_df
        data_pkg["nifty_df"] = nifty_df
        data_pkg["bank_df"] = bank_df
        data_pkg["market_cap"] = info.get('marketCap', 0) / 1e7
        data_pkg["total_debt"] = info.get('totalDebt', 0) / 1e7
        data_pkg["st_debt"] = get_debt_val(['Current Debt', 'Short Term Borrowings'])
        data_pkg["lt_debt"] = get_debt_val(['Long Term Debt', 'Long Term Borrowings'])
        
        if data_pkg["total_debt"] == 0:
            data_pkg["total_debt"] = data_pkg["st_debt"] + data_pkg["lt_debt"]
            
        data_pkg["ltp"] = stock_df['Close'].iloc[-1]
        data_pkg["valid"] = True
        
    except Exception as e:
        data_pkg["error"] = str(e)
    return data_pkg

# --- HELPER: Comparison Data ---
def get_simple_data(ticker, start_date):
    try:
        data = yf.download(ticker, start=start_date, progress=False)
        if isinstance(data.columns, pd.MultiIndex):
            data.columns = data.columns.get_level_values(0)
        return data
    except: return pd.DataFrame()

# --- TAB SETUP ---
tab_sel, tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
    " üîç Selection", 
    " üíé Analysis & Valuation", 
    " üèóÔ∏è Structure", 
    " üîÆ Strategy", 
    " ‚ö†Ô∏è Market Risk", 
    " üìâ Credit Risk",
    " ‚öñÔ∏è Comparison"
])

# --- TAB 0: SELECTION ---
with tab_sel:
    st.title("Asset Selection & Strategic Parameters")
    sel_mode = st.selectbox("Select Asset", ["RELIANCE.NS", "TCS.NS", "HDFCBANK.NS", "INFY.NS", "SBIN.NS", "TATAMOTORS.NS", "Others"])
    if sel_mode == "Others":
        sel_stock = st.text_input("Enter Yahoo Ticker", "ETERNAL.NS").upper()
    else: sel_stock = sel_mode

    col_s1, col_s2 = st.columns(2)
    with col_s1: lookback_yrs = st.slider("Years of Data", 1, 15, 5)
    with col_s2: rf_rate = st.number_input("Risk Free Rate %", value=7.1) / 100
        
    if st.button("üîÑ Initialize Analytics Engine"):
        st.cache_data.clear()
        st.rerun()

# --- ENGINE START ---
master_data = fetch_master_data(sel_stock, lookback_yrs)

if not master_data["valid"]:
    st.error(f"‚ùå Error: {master_data['error']}")
else:
    df = master_data["stock_df"]
    nifty = master_data["nifty_df"]
    bank_nifty = master_data["bank_df"]
    
    returns = df['Close'].pct_change().dropna()
    if not nifty.empty:
        common_idx = returns.index.intersection(nifty.index)
        returns = returns.loc[common_idx]
        mkt_rets = nifty['Close'].pct_change().dropna().loc[common_idx]
    else:
        mkt_rets = pd.Series(np.random.normal(0, 0.01, len(returns)), index=returns.index)

    ann_ret_raw = returns.mean() * 252
    ann_vol = returns.std() * np.sqrt(252)
    days_hist = (df.index[-1] - df.index[0]).days
    cagr = ((df['Close'].iloc[-1] / df['Close'].iloc[0]) ** (365/days_hist)) - 1

    # --- TAB 1: ANALYSIS & VALUATION (Restored Charts) ---
    with tab1:
        st.title(f"Analysis & Valuation: {sel_stock}")
        st.write(f"**LTP:** ‚Çπ{master_data['ltp']:,.2f}")

        # 1. Technical Charts (Restored)
        st.subheader("Price Action & Technicals")
        df['SMA_50'] = df['Close'].rolling(50).mean()
        df['BB_Mid'] = df['Close'].rolling(20).mean()
        df['BB_Std'] = df['Close'].rolling(20).std()
        df['BB_Upper'] = df['BB_Mid'] + 2*df['BB_Std']
        df['BB_Lower'] = df['BB_Mid'] - 2*df['BB_Std']

        fig_candle = go.Figure()
        fig_candle.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Price'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['SMA_50'], line=dict(color='orange', width=1), name='SMA 50'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['BB_Upper'], line=dict(color='gray', width=1, dash='dot'), name='BB Upper'))
        fig_candle.add_trace(go.Scatter(x=df.index, y=df['BB_Lower'], line=dict(color='gray', width=1, dash='dot'), name='BB Lower'))
        fig_candle.update_layout(height=500, title=f"{sel_stock} Technical Chart")
        st.plotly_chart(fig_candle, use_container_width=True)

        st.subheader("Volume Profile")
        fig_vol = px.bar(df, x=df.index, y='Volume', title="Trading Volume")
        st.plotly_chart(fig_vol, use_container_width=True)

        # 2. Valuation Logic
        st.divider()
        beta = (returns.cov(mkt_rets) * 252) / (mkt_rets.var() * 252)
        capm_exp = rf_rate + beta * (mkt_rets.mean()*252 - rf_rate)
        
        sec_corr = 0.5
        if not bank_nifty.empty:
            b_ret = bank_nifty['Close'].pct_change().dropna()
            idx = returns.index.intersection(b_ret.index)
            if len(idx) > 100: sec_corr = returns.loc[idx].rolling(252).corr(b_ret.loc[idx]).iloc[-1]
            
        ff_exp = rf_rate + (beta * 0.08) + (sec_corr * 0.02)
        apt_exp = capm_exp + 0.015

        st.subheader("Multi-Factor Valuation Alphas")
        v1, v2, v3 = st.columns(3)
        def draw_v(col, name, exp, actual):
            al = actual - exp
            vc = "status-undervalued" if al > 0 else "status-overvalued"
            col.markdown(f"""<div class='valuation-card'><small>{name}</small><h3>Exp: {exp:.2%}</h3>
            <p class='{vc}'>Alpha: {al:+.2%} ({"Undervalued" if al > 0 else "Overvalued"})</p></div>""", unsafe_allow_html=True)
        
        draw_v(v1, "CAPM Model", capm_exp, cagr)
        draw_v(v2, "4-Factor Model", ff_exp, cagr)
        draw_v(v3, "APT Model", apt_exp, cagr)

        # 3. 19-Point Stats
        st.subheader("Advanced Statistics")
        dd = (df['Close'] - df['Close'].cummax()) / df['Close'].cummax()
        metrics = [
            ("Sharpe", (ann_ret_raw-rf_rate)/ann_vol), ("Sortino", (ann_ret_raw-rf_rate)/(returns[returns<0].std()*np.sqrt(252))),
            ("Calmar", ann_ret_raw/abs(dd.min())), ("CAGR", cagr),
            ("Max Drawdown", dd.min()), ("Vol (Ann.)", ann_vol),
            ("VaR (95%)", np.percentile(returns, 5)), ("CVaR (95%)", returns[returns<=np.percentile(returns,5)].mean()),
            ("Skew", skew(returns)), ("Kurtosis", kurtosis(returns)),
            ("Profit Factor", abs(returns[returns>0].sum()/returns[returns<0].sum())), ("Gain/Pain", returns.sum()/abs(returns[returns<0].sum()))
        ]
        
        cols = st.columns(4)
        for i, (k, v) in enumerate(metrics):
            cols[i % 4].metric(k, f"{v:.2%}" if "ratio" not in k.lower() and "factor" not in k.lower() and "skew" not in k.lower() and "kurtosis" not in k.lower() else f"{v:.2f}")

    # --- TAB 2: STRUCTURE ---
    with tab2:
        st.title("Structural DNA")
        ma200 = df['Close'].rolling(200).mean()
        
        c1, c2, c3 = st.columns(3)
        c1.metric("Trend vs 200-MA", "BULLISH" if master_data['ltp'] > ma200.iloc[-1] else "BEARISH")
        c2.metric("52W High Dist", f"{((master_data['ltp']/df['Close'].max())-1):.2%}")
        c3.metric("Support (22D Low)", f"‚Çπ{df['Close'].tail(22).min():.2f}")

        st.subheader("Price Memory (Support/Resistance)")
        fig_sr = go.Figure()
        fig_sr.add_trace(go.Scatter(x=df.tail(252).index, y=df['Close'].tail(252), name="Price"))
        fig_sr.add_hline(y=df['Close'].tail(22).max(), line_dash="dash", line_color="green", annotation_text="Res")
        fig_sr.add_hline(y=df['Close'].tail(22).min(), line_dash="dash", line_color="red", annotation_text="Sup")
        st.plotly_chart(fig_sr, use_container_width=True)

    # --- TAB 3: STRATEGY (Restored Forecasts) ---
    with tab3:
        st.title("GARCH Volatility & Strategy")
        ret_g = 100 * returns
        am = arch_model(ret_g, vol='Garch', p=1, q=1, dist='t')
        res_g = am.fit(disp="off")

        # 1. Plots: Volatility & NIC
        c1, c2 = st.columns(2)
        with c1:
            st.subheader("Conditional Volatility")
            fig_v = go.Figure()
            fig_v.add_trace(go.Scatter(x=res_g.conditional_volatility.index, y=res_g.conditional_volatility, line=dict(color='orange')))
            st.plotly_chart(fig_v, use_container_width=True)
        
        with c2:
            st.subheader("News Impact Curve")
            params = res_g.params
            nic_x = np.linspace(ret_g.min(), ret_g.max(), 100)
            nic_y = params['omega'] + params['alpha[1]']*(nic_x**2) + params['beta[1]']*res_g.conditional_volatility.var()
            fig_nic = go.Figure(go.Scatter(x=nic_x, y=nic_y, line=dict(color='firebrick')))
            st.plotly_chart(fig_nic, use_container_width=True)

        # 2. 5-Day Forecast (Restored)
        st.subheader("Short-Term Forecast (Next 5 Days)")
        f_cast = res_g.forecast(horizon=5)
        v_cast = np.sqrt(f_cast.variance.iloc[-1])
        fig_fc = px.bar(x=[f"Day {i+1}" for i in range(5)], y=v_cast, title="Predicted Volatility Shock", labels={'y':'Volatility %'})
        st.plotly_chart(fig_fc, use_container_width=True)

        # 3. Backtester
        st.divider()
        st.subheader("Strategy Simulation (1-Year)")
        strat = st.selectbox("Strategy", ["Triple Golden Cross", "RSI", "SMA Crossover"])
        
        # Sim Data
        sim_vol = np.sqrt(res_g.forecast(horizon=252).variance.values[-1, :])/100
        sim_p = [master_data['ltp']]
        np.random.seed(42)
        for i in range(252): sim_p.append(sim_p[-1]*np.exp(returns.mean() + sim_vol[i]*np.random.normal()))
        
        df_f = pd.DataFrame({'Close': sim_p[1:]}, index=[df.index[-1]+timedelta(days=i) for i in range(1, 253)])
        
        if strat == "Triple Golden Cross":
            df_f['S'], df_f['M'], df_f['L'] = df_f['Close'].rolling(10).mean(), df_f['Close'].rolling(50).mean(), df_f['Close'].rolling(200).mean()
            df_f['Signal'] = np.where((df_f['S']>df_f['M']) & (df_f['S']<df_f['L']), 1, 0)
        elif strat == "RSI":
            delta = df_f['Close'].diff()
            g, l = delta.where(delta>0,0).rolling(14).mean(), -delta.where(delta<0,0).rolling(14).mean()
            df_f['RSI'] = 100 - (100/(1+(g/l)))
            df_f['Signal'] = np.where(df_f['RSI']<30, 1, 0)
        else:
            df_f['Signal'] = np.where(df_f['Close'].rolling(20).mean()>df_f['Close'].rolling(50).mean(), 1, 0)
            
        fig_sim = go.Figure()
        fig_sim.add_trace(go.Scatter(x=df_f.index, y=df_f['Close'], name='Forecast'))
        buys = df_f[df_f['Signal'].diff()==1]
        fig_sim.add_trace(go.Scatter(x=buys.index, y=buys['Close'], mode='markers', marker=dict(symbol='triangle-up', size=10, color='green'), name='Buy'))
        st.plotly_chart(fig_sim, use_container_width=True)

    # --- TAB 4: MARKET RISK ---
    with tab4:
        st.title("Market Risk Analysis")
        
        c1, c2 = st.columns(2)
        with c1:
            st.subheader("Rolling Beta (60D)")
            cov = returns.rolling(60).cov(mkt_rets)
            beta_roll = cov / mkt_rets.rolling(60).var()
            st.line_chart(beta_roll)
        with c2:
            st.subheader("QQ Plot")
            qq = probplot(returns, dist="norm")
            fig_qq = px.scatter(x=qq[0][0], y=qq[0][1], labels={'x':'Theoretical','y':'Sample'})
            fig_qq.add_trace(go.Scatter(x=[-3,3], y=[-3*returns.std(), 3*returns.std()], mode='lines', line=dict(color='red')))
            st.plotly_chart(fig_qq, use_container_width=True)
            
        st.subheader("Stress Testing (Hypothetical P&L)")
        capital = st.number_input("Portfolio Capital (‚Çπ)", 100000)
        scenarios = {"Mild (-10%)": -0.1, "Bear (-20%)": -0.2, "Crash (-30%)": -0.3}
        stress_df = pd.DataFrame([{"Event": k, "Loss": capital*v} for k,v in scenarios.items()])
        st.bar_chart(stress_df.set_index("Event"))

    # --- TAB 5: CREDIT RISK ---
    with tab5:
        st.title("Credit Risk (Merton/KMV)")
        st.info(f"Total Debt: ‚Çπ{master_data['total_debt']:,.2f} Cr | Market Cap: ‚Çπ{master_data['market_cap']:,.2f} Cr")
        
        barr = st.number_input("Default Barrier (Debt Threshold)", value=float(master_data['total_debt']))
        
        def solve_merton(p):
            V, sv = p; T=1; r=rf_rate; L=barr; E=master_data['market_cap']; se=ann_vol
            d1 = (np.log(V/L) + (r + 0.5*sv**2)*T) / (sv*np.sqrt(T))
            d2 = d1 - sv*np.sqrt(T)
            return [V*norm.cdf(d1) - L*np.exp(-r*T)*norm.cdf(d2) - E, (norm.cdf(d1)*V/E)*sv - se]
            
        try:
            if barr>0:
                V_impl, sv_impl = fsolve(solve_merton, [master_data['market_cap']+barr, ann_vol])
                dd = (np.log(V_impl/barr) + (rf_rate - 0.5*sv_impl**2)) / sv_impl
                st.metric("Distance to Default", f"{dd:.2f} œÉ")
                st.metric("Probability of Default", f"{norm.cdf(-dd):.4%}")
            else: st.warning("Debt data unavailable for calculation.")
        except: st.error("Solver failed due to extreme data values.")

    # --- TAB 6: COMPARISON ---
    with tab6:
        st.title("Multi-Stock Comparison")
        comp_str = st.text_input("Tickers (comma sep)", "RELIANCE.NS, TCS.NS, HDFCBANK.NS")
        
        if st.button("Compare Peers"):
            tickers = [x.strip() for x in comp_str.split(',')]
            res_list = []
            start_dt = (datetime.now()-timedelta(days=lookback_yrs*365)).strftime('%Y-%m-%d')
            
            for t in tickers:
                d = get_simple_data(t, start_dt)
                if not d.empty:
                    ret = d['Close'].pct_change().dropna()
                    res_list.append({
                        "Ticker": t,
                        "Returns": (d['Close'].iloc[-1]/d['Close'].iloc[0])-1,
                        "Vol": ret.std()*np.sqrt(252),
                        "Sharpe": ret.mean()/ret.std()*np.sqrt(252),
                        "MaxDD": ((d['Close']-d['Close'].cummax())/d['Close'].cummax()).min()
                    })
            
            comp_df = pd.DataFrame(res_list).set_index("Ticker")
            
            # Winner Logic
            best = {}
            for c in comp_df.columns:
                if c in ["Vol", "MaxDD"]: best[c] = comp_df[c].idxmin() # Lower is better
                else: best[c] = comp_df[c].idxmax() # Higher is better
            
            comp_df.loc['üèÜ WINNER'] = pd.Series(best)
            st.table(comp_df)


